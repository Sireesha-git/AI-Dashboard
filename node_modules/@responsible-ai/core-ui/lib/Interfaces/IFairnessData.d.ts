import { Never } from "../util/Never";
import { IDatasetSummary } from "./IDataset";
export declare enum PredictionTypes {
    BinaryClassification = "binaryClassification",
    Regression = "regression",
    Probability = "probability"
}
export declare type PredictionType = PredictionTypes.BinaryClassification | PredictionTypes.Probability | PredictionTypes.Regression;
export interface IBounds {
    lower: number;
    upper: number;
}
export interface IMetricResponse {
    global: number;
    bins: number[];
    bounds?: IBounds;
    binBounds?: IBounds[];
}
export interface IMetricRequest {
    metricKey: string;
    binVector: number[];
    modelIndex: number;
    errorBarsEnabled?: boolean;
}
export interface IFairnessResponse {
    overall: number;
    bounds?: IBounds;
}
export interface IFeatureBinMeta {
    binVector: number[];
    binLabels: string[];
    featureBinName?: string;
}
export interface ICustomMetric {
    name?: string;
    description?: string;
    id: string;
}
export interface IFairnessBaseData {
    dataSummary?: IDatasetSummary;
    predictedY: number[][];
    modelNames?: string[];
    trueY: number[];
    testData?: any[][];
    errorBarsEnabled?: boolean;
}
export interface IPreComputedData {
    precomputedMetrics: Array<Array<{
        [key: string]: IMetricResponse;
    }>>;
    precomputedFeatureBins: IFeatureBinMeta[];
    predictionType: PredictionTypes;
    customMetrics?: ICustomMetric[];
}
export declare type IRunTimeData = Never<IPreComputedData> & {
    testData: any[][];
};
export declare type IPreComputedFairnessData = IFairnessBaseData & IPreComputedData;
export declare type IRunTimeFairnessData = IFairnessBaseData & IRunTimeData;
export declare type IFairnessData = IPreComputedFairnessData | IRunTimeFairnessData;
