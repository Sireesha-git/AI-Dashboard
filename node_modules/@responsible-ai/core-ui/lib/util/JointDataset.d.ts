import { ModelTypes } from "../Interfaces/IExplanationContext";
import { WeightVectorOption } from "../Interfaces/IWeightedDropdownContext";
import { IJointDatasetArgs, IJointMeta, IDatasetMeta } from "./JointDatasetUtils";
export declare class JointDataset {
    static readonly IndexLabel = "Index";
    static readonly AbsoluteIndexLabel = "AbsoluteIndex";
    static readonly DataLabelRoot = "Data";
    static readonly PredictedYLabel = "PredictedY";
    static readonly ProbabilityYRoot = "ProbabilityClass";
    static readonly TrueYLabel = "TrueY";
    static readonly ObjectDetectionCorrect = "Correct";
    static readonly ObjectDetectionIncorrect = "Incorrect";
    static readonly ObjectDetectionLabels = "ObjectDetectionLabels";
    static readonly DitherLabel = "Dither";
    static readonly DitherLabel2 = "Dither2";
    static readonly ClassificationError = "ClassificationError";
    static readonly RegressionError = "RegressionError";
    static readonly ReducedLocalImportanceRoot = "LocalImportance";
    static readonly ReducedLocalImportanceIntercept = "LocalImportanceIntercept";
    static readonly ReducedLocalImportanceSortIndexRoot = "LocalImportanceSortIndex";
    datasetMetaData: IDatasetMeta | undefined;
    rawLocalImportance: number[][][] | undefined;
    metaDict: {
        [key: string]: IJointMeta;
    };
    hasDataset: boolean;
    hasLocalExplanations: boolean;
    hasPredictedY: boolean;
    hasPredictedProbabilities: boolean;
    hasTrueY: boolean;
    hasODIncorrect: boolean;
    hasODCorrect: boolean;
    datasetFeatureCount: number;
    predictionClassCount: number;
    datasetRowCount: number;
    localExplanationFeatureCount: number;
    numLabels: number;
    dataDict: Array<{
        [key: string]: number;
    }> | undefined;
    strDataDict: Array<{
        [key: string]: string;
    }> | undefined;
    binDict: {
        [key: string]: number[] | undefined;
    };
    private readonly _modelMeta;
    private numericValuedColumnsCache;
    private readonly ditherScale;
    constructor(args: IJointDatasetArgs);
    static unwrap(dataset: Array<{
        [key: string]: any;
    }>, key: string, binVector?: number[]): any[];
    static datasetSlice(row: {
        [key: string]: any;
    }, metaDict: {
        [key: string]: IJointMeta;
    }, length: number): any[];
    static localExplanationSlice(row: {
        [key: string]: any;
    }, length: number): number[];
    static predictProbabilitySlice(row: {
        [key: string]: any;
    }, length: number): number[];
    static setErrorMetrics(row: {
        [key: string]: any;
    }, modelType: ModelTypes, numLabels?: number): void;
    static buildLocalFeatureMatrix(localExplanationRaw: number[][] | number[][][], modelType: ModelTypes): number[][][];
    private static transposeLocalImportanceMatrix;
    getModelType(): ModelTypes;
    getModelClasses(): any[];
    getRow(index: number): {
        [key: string]: number;
    };
    unwrap(key: string, binVector?: number[]): any[];
    readonly getRawValue: (v: number | undefined, k: string) => string | number | undefined;
    setTreatAsCategorical(key: string, value: boolean): void;
    setLogarithmicScaling(key: string, value: boolean): void;
    addBin(key: string, binCountIn?: number): void;
    buildLocalFlattenMatrix(weightVector: WeightVectorOption): void;
    getJointDatasetFeatureName(userFeatureName: string): string | undefined;
    private initializeDatasetVariables;
    private initializeLabelVariables;
    private initializeErrorVariables;
    private updateMetaDataDict;
    private initializeDataDictIfNeeded;
}
