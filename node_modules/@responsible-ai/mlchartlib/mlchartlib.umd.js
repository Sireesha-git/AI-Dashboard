(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('lodash'), require('react'), require('react-plotly.js'), require('uuid'), require('@fluentui/react'), require('moment'), require('jmespath'), require('plotly.js')) :
    typeof define === 'function' && define.amd ? define(['exports', 'lodash', 'react', 'react-plotly.js', 'uuid', '@fluentui/react', 'moment', 'jmespath', 'plotly.js'], factory) :
    (global = global || self, factory(global.Mlchartlib = {}, global._, global.React, global.Plot, global.uuid, global.react, global.moment, global.jmespath, global.Plotly));
}(this, (function (exports, _, React, Plot, uuid, react, moment, jmespath, Plotly) { 'use strict';

    _ = _ && _.hasOwnProperty('default') ? _['default'] : _;
    React = React && React.hasOwnProperty('default') ? React['default'] : React;
    Plot = Plot && Plot.hasOwnProperty('default') ? Plot['default'] : Plot;
    moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;
    jmespath = jmespath && jmespath.hasOwnProperty('default') ? jmespath['default'] : jmespath;
    Plotly = Plotly && Plotly.hasOwnProperty('default') ? Plotly['default'] : Plotly;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }

    // Copyright (c) Microsoft Corporation.
    var accessibleChartStyles = react.mergeStyleSets({
      chart: {
        height: "100%",
        width: "100%"
      },
      noData: {
        "text-align": "center"
      },
      plotlyTable: {
        border: "0",
        clip: "rect(0 0 0 0)",
        display: "block",
        height: "1px",
        margin: "-1px",
        overflow: "hidden",
        padding: "0",
        position: "absolute",
        width: "1px"
      }
    });

    // Copyright (c) Microsoft Corporation.
    function formatValue(value) {
      if (typeof value === "string") {
        return value;
      }

      if (!value) {
        return "";
      }

      if (_.isDate(value)) {
        return moment(value).format();
      }

      if (!_.isNaN(_.toNumber(value))) {
        var numericalVal = _.toNumber(value);

        if (_.isInteger(numericalVal)) {
          return numericalVal.toString();
        }

        return numericalVal.toPrecision(4);
      }

      if (_.isArray(value)) {
        return "vaector[" + value.length + "]";
      }

      return JSON.stringify(value);
    }

    // Copyright (c) Microsoft Corporation.
    var plotlyLightTheme = {
      axisColor: "#444",
      axisGridColor: "#eee",
      backgroundColor: "#fff",
      fontColor: "#000"
    };
    var plotlyDarkTheme = {
      axisColor: "#aaa",
      axisGridColor: "#222",
      backgroundColor: "#000",
      fontColor: "#fff"
    };
    var plotlyWhiteTheme = {
      axisColor: "#000",
      axisGridColor: "#000",
      backgroundColor: "#fff",
      fontColor: "#000"
    };
    var plotlyBlackTheme = {
      axisColor: "#fff",
      axisGridColor: "#fff",
      backgroundColor: "#000",
      fontColor: "#fff"
    };

    var PlotlyThemes =
    /** @class */
    function () {
      function PlotlyThemes() {}

      PlotlyThemes.applyTheme = function (props, theme, themeOverride) {
        var newProps = _.cloneDeep(props);

        var plotTheme = _.merge(this.getTheme(theme), themeOverride);

        _.set(newProps, "layout.font.color", plotTheme.fontColor);

        _.set(newProps, "layout.paper_bgcolor", plotTheme.backgroundColor);

        _.set(newProps, "layout.plot_bgcolor", plotTheme.backgroundColor);

        _.set(newProps, "layout.xaxis.color", plotTheme.axisColor);

        _.set(newProps, "layout.yaxis.color", plotTheme.axisColor);

        _.set(newProps, "layout.xaxis.gridcolor", plotTheme.axisGridColor);

        _.set(newProps, "layout.yaxis.gridcolor", plotTheme.axisGridColor);

        return newProps;
      };

      PlotlyThemes.getTheme = function (theme) {
        if (typeof theme === "string" || theme === undefined) {
          switch (theme) {
            case undefined:
            case "light":
              return plotlyLightTheme;

            case "dark":
              return plotlyDarkTheme;

            case "white":
              return plotlyWhiteTheme;

            case "black":
              return plotlyBlackTheme;

            default:
              return plotlyLightTheme;
          }
        }

        return _.defaults({
          axisColor: theme.semanticColors.bodyText,
          axisGridColor: theme.semanticColors.bodySubtext,
          backgroundColor: theme.semanticColors.bodyBackground,
          fontColor: theme.semanticColors.bodyText
        }, plotlyLightTheme);
      };

      return PlotlyThemes;
    }();

    // Copyright (c) Microsoft Corporation.

    var AccessibleChart =
    /** @class */
    function (_super) {
      __extends(AccessibleChart, _super);

      function AccessibleChart() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.guid = uuid.v4();
        return _this;
      }

      AccessibleChart.prototype.componentWillUnmount = function () {
        if (this.timer) {
          window.clearTimeout(this.timer);
        }
      };

      AccessibleChart.prototype.render = function () {
        var themeOverride = this.props.themeOverride;

        if (!themeOverride && this.props.theme && typeof this.props.theme !== "string") {
          themeOverride = {
            axisColor: this.props.theme.palette.neutralPrimary,
            axisGridColor: this.props.theme.palette.neutralLight,
            backgroundColor: this.props.theme.palette.white,
            fontColor: this.props.theme.semanticColors.bodyText
          };
        }

        if (this.hasData()) {
          var themedProps = this.props.theme ? PlotlyThemes.applyTheme(this.props.plotlyProps, this.props.theme, themeOverride) : _.cloneDeep(this.props.plotlyProps);
          return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Plot, {
            className: accessibleChartStyles.chart,
            data: themedProps.data,
            layout: __assign(__assign({}, themedProps.layout), this.props.relayoutArg),
            config: themedProps.config,
            onClick: this.props.onClickHandler
          }), this.createTableWithPlotlyData(this.props.plotlyProps.data));
        }

        return /*#__PURE__*/React.createElement("div", {
          className: accessibleChartStyles.noData
        }, this.props.localizedStrings ? this.props.localizedStrings.noData : "No Data");
      };

      AccessibleChart.prototype.hasData = function () {
        return this.props.plotlyProps && this.props.plotlyProps.data.length > 0 && _.some(this.props.plotlyProps.data, function (datum) {
          return !_.isEmpty(datum.y) || !_.isEmpty(datum.x);
        });
      };

      AccessibleChart.prototype.createTableWithPlotlyData = function (data) {
        return /*#__PURE__*/React.createElement("table", {
          className: accessibleChartStyles.plotlyTable
        }, /*#__PURE__*/React.createElement("tbody", null, data.map(function (datum, index) {
          var xDataLength = datum.x ? datum.x.length : 0;
          var yDataLength = datum.y ? datum.y.length : 0;
          var tableWidth = Math.max(xDataLength, yDataLength); // Building this table is slow, need better accessibility for large charts than an unreadable table

          if (tableWidth > 500) {
            return undefined;
          }

          var xRowCells = [];
          var yRowCells = [];

          for (var i = 0; i < tableWidth; i++) {
            // Add String() because sometimes data may be Nan
            xRowCells.push( /*#__PURE__*/React.createElement("td", {
              key: i + ".x"
            }, datum.x ? formatValue(datum.x[i]) : ""));
            yRowCells.push( /*#__PURE__*/React.createElement("td", {
              key: i + ".y"
            }, datum.y ? formatValue(datum.y[i]) : ""));
          }

          return [/*#__PURE__*/React.createElement("tr", {
            key: index + ".x"
          }, xRowCells), /*#__PURE__*/React.createElement("tr", {
            key: index + ".y"
          }, yRowCells)];
        })));
      };

      return AccessibleChart;
    }(React.Component);

    // Copyright (c) Microsoft Corporation.

    (function (AccessorMappingFunctionNames) {
      AccessorMappingFunctionNames["StringifyText"] = "string";
    })(exports.AccessorMappingFunctionNames || (exports.AccessorMappingFunctionNames = {}));

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT License.
    var _a;
    // a jmes query.

    var stringify = function stringify(value, _datum, args) {
      var minLength = Math.min(args.length, value.length);
      var result = [];

      for (var i = 0; i < minLength; i++) {
        var formattedValue = value[i];

        if (typeof formattedValue === "number") {
          formattedValue = formattedValue.toLocaleString(undefined, {
            minimumFractionDigits: 2
          });
        }

        result[i] = args[i] + ": " + formattedValue;
      }

      return result.join("<br>");
    };

    var accessorMappingFunctions = (_a = {}, _a[exports.AccessorMappingFunctionNames.StringifyText] = stringify, _a);

    // Copyright (c) Microsoft Corporation.

    var ChartBuilder =
    /** @class */
    function () {
      function ChartBuilder() {}

      ChartBuilder.buildPlotlySeries = function (datum, rows) {
        var groupingDictionary = {};
        var defaultSeries;
        var datumLevelPaths = datum.datapointLevelAccessors ? ", " + Object.keys(datum.datapointLevelAccessors).map(function (key) {
          var _a;

          return key + ": [" + ((_a = datum.datapointLevelAccessors) === null || _a === void 0 ? void 0 : _a[key].path.join(", ")) + "]";
        }).join(", ") : "";
        var projectedRows = jmespath.search(rows, (datum.xAccessorPrefix || "") + "[*].{x: " + datum.xAccessor + ", y: " + datum.yAccessor + ", group: " + datum.groupBy + ", size: " + datum.sizeAccessor + datumLevelPaths + "}"); // for bubble charts, we scale all sizes to the max size, only needs to be done once since its global
        // Due to https://github.com/plotly/plotly.js/issues/2080 we have to set size explicitly rather than use
        // the preferred solution of size ref

        var maxBubbleValue = 10;
        projectedRows.forEach(function (row) {
          var _a, _b;

          var _c;

          var series; // Handle mutiple group by in the future

          if (datum.groupBy && datum.groupBy.length > 0) {
            var key = row.group;

            if (key === undefined || key === null) {
              if (defaultSeries === undefined) {
                defaultSeries = ChartBuilder.buildDefaultSeries(datum);
              }

              series = defaultSeries;
            } else {
              if (groupingDictionary[key] === undefined) {
                var temp = ChartBuilder.buildDefaultSeries(datum);
                temp.name = key;
                groupingDictionary[key] = temp;
              }

              series = groupingDictionary[key];
            }
          } else {
            if (defaultSeries === undefined) {
              defaultSeries = ChartBuilder.buildDefaultSeries(datum);
            }

            series = defaultSeries;
          } // Due to logging supporting heterogeneous metric types, a metric can be a scalar on one run and a vector on another
          // Support these cases in the minimally surprising way by upcasting a scalar point to match the highest dimension for that row (like numpy does)
          // If two arrays are logged, but of different lengths, pad the shorter ones with undefined to avoid series having different lengths concatted.
          // We always have a size of at least one, this avoids corner case of one array being empty


          var _d = ChartBuilder.getHasVectors(row),
              hasVectorValues = _d.hasVectorValues,
              maxLength = _d.maxLength;

          if (hasVectorValues) {
            // for making scalars into a vector, fill the vector with that scalar value
            if (!Array.isArray(row.x)) {
              row.x = new Array(maxLength).fill(row.x);
            }

            if (!Array.isArray(row.y)) {
              row.y = new Array(maxLength).fill(row.y);
            }

            if (!Array.isArray(row.size)) {
              row.size = new Array(maxLength).fill(row.size);
            } // for padding too-short of arrays, set length to be uniform


            row.x.length = maxLength;
            row.y.length = maxLength;
            row.size.length = maxLength;
          }

          if (datum.xAccessor) {
            if (Array.isArray(row.x)) {
              (_a = series.x).push.apply(_a, __spreadArray([], __read(row.x)));
            } else {
              series.x.push(row.x);
            }
          }

          if (datum.yAccessor) {
            if (Array.isArray(row.y)) {
              (_b = series.y).push.apply(_b, __spreadArray([], __read(row.y)));
            } else {
              series.y.push(row.y);
            }
          }

          if (datum.sizeAccessor) {
            var size = row.size * Math.pow(datum.maxMarkerSize || 40, 2) / (2 * maxBubbleValue);
            ((_c = series.marker) === null || _c === void 0 ? void 0 : _c.size).push(Math.abs(size));
          }

          if (datum.datapointLevelAccessors !== undefined) {
            Object.keys(datum.datapointLevelAccessors).forEach(function (key) {
              var _a;

              if (!datum.datapointLevelAccessors) {
                return;
              }

              var accessor = datum.datapointLevelAccessors[key];
              var plotlyPath = accessor.plotlyPath;
              var value = accessor.mapFunction !== undefined ? accessorMappingFunctions[accessor.mapFunction](row[key], datum, accessor.mapArgs || []) : row[key];

              if (hasVectorValues) {
                if (!Array.isArray(value)) {
                  value = new Array(maxLength).fill(value);
                }

                value.length = maxLength;
              }

              if (!_.has(series, plotlyPath)) {
                _.set(series, plotlyPath, []);
              }

              if (Array.isArray(value)) {
                (_a = _.get(series, plotlyPath)).push.apply(_a, __spreadArray([], __read(value)));
              } else {
                _.get(series, plotlyPath).push(value);
              }
            });
          }
        });
        var result = defaultSeries !== undefined ? [defaultSeries] : [];
        Object.keys(groupingDictionary).forEach(function (key) {
          result.push(groupingDictionary[key]);
        });
        return result;
      };

      ChartBuilder.getHasVectors = function (row) {
        var maxLength = 1;
        var hasVectorValues = false;

        if (Array.isArray(row.x)) {
          hasVectorValues = true;
          maxLength = Math.max(maxLength, row.x.length);
        }

        if (Array.isArray(row.y)) {
          hasVectorValues = true;
          maxLength = Math.max(maxLength, row.y.length);
        }

        if (Array.isArray(row.size)) {
          hasVectorValues = true;
          maxLength = Math.max(maxLength, row.size.length);
        }

        return {
          hasVectorValues: hasVectorValues,
          maxLength: maxLength
        };
      };

      ChartBuilder.buildDefaultSeries = function (datum) {
        var series = _.cloneDeep(datum); // defining an x/y accessor will overwrite any hardcoded x or y values.


        if (datum.xAccessor) {
          series.x = [];
        }

        if (datum.yAccessor) {
          series.y = [];
        }

        if (datum.sizeAccessor) {
          if (series.marker) {
            series.marker.size = [];
          }
        }

        if (datum.datapointLevelAccessors !== undefined) {
          Object.keys(datum.datapointLevelAccessors).forEach(function (key) {
            var _a;

            var plotlyPath = (_a = datum.datapointLevelAccessors) === null || _a === void 0 ? void 0 : _a[key].plotlyPath;

            if (plotlyPath) {
              _.set(series, plotlyPath, []);
            }
          });
        }

        return series;
      };

      return ChartBuilder;
    }();

    // Copyright (c) Microsoft Corporation.

    var DefaultSelectionFunctions =
    /** @class */
    function () {
      function DefaultSelectionFunctions() {}

      DefaultSelectionFunctions.scatterSelection = function (guid, selections, plotlyProps) {
        var selectedPoints = selections.length === 0 ? undefined : plotlyProps.data.map(function (trace) {
          var selectedIndexes = [];

          if (trace.customdata) {
            trace.customdata.forEach(function (data, index) {
              var id = data === null || data === void 0 ? void 0 : data.toString();

              if (id && selections.includes(id)) {
                selectedIndexes.push(index);
              }
            });
          }

          return selectedIndexes;
        });
        Plotly.restyle(guid, "selectedpoints", selectedPoints);
        var newLineWidths = selections.length === 0 ? [0] : plotlyProps.data.map(function (trace) {
          if (trace.customdata) {
            var customData = trace.customdata;
            var newWidths_1 = new Array(customData.length).fill(0);
            customData.forEach(function (data, index) {
              var id = data === null || data === void 0 ? void 0 : data.toString();

              if (id && selections.includes(id)) {
                newWidths_1[index] = 2;
              }
            });
            return newWidths_1;
          }

          return [0];
        });
        Plotly.restyle(guid, "marker.line.width", newLineWidths);
      };

      return DefaultSelectionFunctions;
    }();

    // Copyright (c) Microsoft Corporation.

    (function (RangeTypes) {
      RangeTypes["Categorical"] = "categorical";
      RangeTypes["Integer"] = "integer";
      RangeTypes["Numeric"] = "numeric";
    })(exports.RangeTypes || (exports.RangeTypes = {}));

    // Copyright (c) Microsoft Corporation.

    var ModelMetadata =
    /** @class */
    function () {
      function ModelMetadata() {}

      ModelMetadata.buildFeatureRanges = function (testData, isCategoricalArray, categoricalMap) {
        if (testData === undefined || isCategoricalArray === undefined) {
          return undefined;
        }

        return isCategoricalArray.map(function (isCategorical, featureIndex) {
          if (isCategorical) {
            if (categoricalMap && categoricalMap[featureIndex] !== undefined) {
              return {
                rangeType: exports.RangeTypes.Categorical,
                uniqueValues: categoricalMap[featureIndex]
              };
            }

            var featureVector_1 = testData.map(function (row) {
              return row[featureIndex];
            });
            return {
              rangeType: exports.RangeTypes.Categorical,
              uniqueValues: _.uniq(featureVector_1)
            };
          }

          var featureVector = testData.map(function (row) {
            return row[featureIndex];
          });
          return {
            max: _.max(featureVector) || 0,
            min: _.min(featureVector) || 0,
            rangeType: featureVector.every(function (val) {
              return Number.isInteger(val);
            }) ? exports.RangeTypes.Integer : exports.RangeTypes.Numeric
          };
        });
      };

      ModelMetadata.buildIsCategorical = function (featureLength, testData, categoricalMap) {
        var featureIndexArray = __spreadArray([], __read(new Array(featureLength).keys()));

        if (categoricalMap) {
          return featureIndexArray.map(function (i) {
            return categoricalMap[i] !== undefined;
          });
        }

        if (testData) {
          return featureIndexArray.map(function (featureIndex) {
            return !testData.every(function (row) {
              return typeof row[featureIndex] === "number";
            });
          });
        }

        return undefined;
      };

      return ModelMetadata;
    }();

    // Copyright (c) Microsoft Corporation.

    (function (PlotlyMode) {
      PlotlyMode["Lines"] = "lines";
      PlotlyMode["Markers"] = "markers";
      PlotlyMode["Text"] = "text";
      PlotlyMode["LinesMarkers"] = "lines+markers";
      PlotlyMode["TextMarkers"] = "text+markers";
      PlotlyMode["TextLines"] = "text+lines";
      PlotlyMode["TextLinesMarkers"] = "text+lines+markers";
      PlotlyMode["None"] = "none";
    })(exports.PlotlyMode || (exports.PlotlyMode = {}));

    // Copyright (c) Microsoft Corporation.

    var SelectionContext =
    /** @class */
    function () {
      function SelectionContext(propertyOfInterest, maxItems) {
        this.selectedIds = [];
        this.listenerCount = 0;
        this.selectionSubs = new Map();
        this.hoverSubs = new Map();
        this.countSubs = new Map();
        this.propertyOfInterest = propertyOfInterest;
        this.maxItems = maxItems;
      }

      SelectionContext.prototype.onSelect = function (newSelections) {
        // Keep the most recently added selections
        if (this.maxItems !== undefined) {
          newSelections = newSelections.slice(Math.max(newSelections.length - this.maxItems, 0));
        }

        this.selectedIds = newSelections;
        this.selectionSubs.forEach(function (sub) {
          return sub(newSelections);
        });
      };

      SelectionContext.prototype.onHover = function (newItem) {
        this.hoveredId = newItem;
        this.hoverSubs.forEach(function (sub) {
          return sub(newItem);
        });
      };

      SelectionContext.prototype.subscribe = function (subs) {
        var _this = this;

        var id = uuid.v4();
        this.selectionSubs.set(id, subs.selectionCallback);

        if (subs.hoverCallback) {
          this.hoverSubs.set(id, subs.hoverCallback);
        }

        if (subs.listenerCountCallback) {
          this.countSubs.set(id, subs.listenerCountCallback);
        }

        this.listenerCount += 1;
        this.countSubs.forEach(function (val) {
          return val(_this.listenerCount);
        });
        return id;
      };

      SelectionContext.prototype.unsubscribe = function (id) {
        this.selectionSubs["delete"](id);
        this.hoverSubs["delete"](id);
        this.countSubs["delete"](id);
        this.listenerCount -= 1;
      };

      return SelectionContext;
    }();

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT License.
    function roundDecimal(value) {
      return value % 1 !== 0 ? Math.round(value * 10000) / 10000 : value;
    }

    // Copyright (c) Microsoft Corporation.
    var theme = react.getTheme();
    var chartColors = [theme.palette.blue, theme.palette.orangeLighter //"#ff7f0e"
    ];

    exports.AccessibleChart = AccessibleChart;
    exports.ChartBuilder = ChartBuilder;
    exports.DefaultSelectionFunctions = DefaultSelectionFunctions;
    exports.ModelMetadata = ModelMetadata;
    exports.PlotlyThemes = PlotlyThemes;
    exports.SelectionContext = SelectionContext;
    exports.accessorMappingFunctions = accessorMappingFunctions;
    exports.chartColors = chartColors;
    exports.roundDecimal = roundDecimal;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
