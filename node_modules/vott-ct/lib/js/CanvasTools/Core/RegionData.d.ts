import { ICubicBezierControl } from "../Interface/ICubicBezierControl";
import { ILineSegment } from "../Interface/ILineSegment";
import { IMovable } from "../Interface/IMovable";
import { IPoint2D } from "../Interface/IPoint2D";
import { IRect } from "../Interface/IRect";
import { IRegionData } from "../Interface/IRegionData";
import { IResizable } from "../Interface/IResizable";
import { RegionDataType } from "../Interface/RegionDataType";
import { CubicBezierControl } from "./CubicBezierControl";
import { CubicBezierIndex } from "./CubicBezierIndex";
import { Point2D } from "./Point2D";
import { Rect } from "./Rect";
export { RegionDataType };
/**
 * Represents region meta-data, including position, size, points and type
 */
export declare class RegionData implements IRegionData, IMovable, IResizable {
    /**
     * Creates a new `RegionData` object with `point`-type at provided `x`, `y` coordinates
     * @param x - `x`-coordinate
     * @param y - `y`-coordinate
     * @returns A new `RegionData` object
     */
    static BuildPointRegionData(x: number, y: number): RegionData;
    /**
     * Creates a new `RegionData` object with `rect`-type at provided `x`, `y`
     * coordinates and of provided `width` and `height`
     * @param x - `x`-coordinate
     * @param y - `y`-coordinate
     * @param width - `width` of the rect
     * @param height - `height` of the rect
     * @returns A new `RegionData` object
     */
    static BuildRectRegionData(x: number, y: number, width: number, height: number): RegionData;
    /**
     * Creates a new `RegionData` object with `polygon`-type at provided `x`, `y`
     * coordinates and of provided `width` and `height`
     * @param x - `x`-coordinate
     * @param y - `y`-coordinate
     * @param width - `width` of the bounding rect
     * @param height - `height` of the bounding rect
     * @param points - the points that make up the polygon
     * @returns A new `RegionData` object
     */
    static BuildPolygonRegionData(x: number, y: number, width: number, height: number, points: Point2D[]): RegionData;
    /**
     * Creates a new `RegionData` object with `path`-type at provided `x`, `y`
     * coordinates and of provided `width` and `height`
     *
     * path region types can represent complex shapes including bezier curves
     *
     * @param x - `x`-coordinate
     * @param y - `y`-coordinate
     * @param width - `width` of the bounding rect
     * @param height - `height` of the bounding rect
     * @param points - the points the path
     * @param bezierControls - Map of bezier controls to lines in the path
     * @returns A new `RegionData` object
     */
    static BuildPathRegionData(x: number, y: number, width: number, height: number, points: IPoint2D[], bezierControls: Record<number, ICubicBezierControl>): RegionData;
    /**
     * Creates a new `RegionData` object based on extracting specific properties from any provided object
     * @param data - An `IRegionData` object with `x`, `y`, `width`, `height`, `points` and `type` properties
     * @returns A new `RegionData` object
     */
    static BuildFromJson(data: IRegionData): RegionData;
    protected corner: Point2D;
    protected regionRect: Rect;
    protected regionPoints: Point2D[];
    protected regionBezierControls: CubicBezierIndex;
    protected regionType: RegionDataType;
    /**
     * Creates a new `RegionData` object
     * @param x - `x`-coordinate of the region
     * @param y - `y`-coordinate of the region
     * @param width - `width` of the region
     * @param height - `height` of the region
     * @param points - Collection of internal region points
     * @param type - `type` of the region from enum `RegionDataType`
     */
    constructor(x: number, y: number, width: number, height: number, points?: Point2D[], type?: RegionDataType, bezierControls?: Record<number, CubicBezierControl>);
    /**
     * Gets the `x`-coordinate of the region
     */
    get x(): number;
    /**
     * Sets the `x`-coordinate of the region. *Region points position will be recalculated*
     */
    set x(x: number);
    /**
     * Gets the `y`-coordinate of the region
     */
    get y(): number;
    /**
     * Sets the `y`-coordinate of the region. *Region points position will be recalculated*
     */
    set y(y: number);
    /**
     * Gets the `width` of the region
     */
    get width(): number;
    /**
     * Sets the `width` of the region. *Region points position will be recalculated*
     */
    set width(width: number);
    /**
     * Gets the `height` of the region
     */
    get height(): number;
    /**
     * Sets the `height` of the region. *Region points position will be recalculated*
     */
    set height(height: number);
    /**
     * Returns the area of the region. *Point has area = 1.0, for other types it is `width * height`*
     */
    get area(): number;
    /**
     * Gets the bounding box size of the region
     */
    get boundRect(): Rect;
    /**
     * Sets the bounding box size of the region. *Region will be resized automatically*
     */
    set boundRect(rect: Rect);
    /**
     * Gets the array of region points.
     */
    get points(): Point2D[];
    /**
     * Sets the array of region points. *Region will be resized and repositioned automatically*
     *
     * @deprecated directly setting point arrays does not work with path regions which contain bezier control points
     * use set/splice methods instead.
     */
    set points(points: Point2D[]);
    /**
     * Bezier controls mapped to line segment indexes.
     */
    get bezierControls(): CubicBezierIndex;
    /**
     * Gets the type of the region
     */
    get type(): RegionDataType;
    /**
     * Moves the region to the position of an `IPoint2D` object
     * @param point - `IPoint2D` object to use as position source
     */
    move(point: IPoint2D): void;
    /**
     * Moves the region to specified coordinates
     * @param x - New `x`-coordinate
     * @param y - New `y`-coordinate
     */
    move(x: number, y: number): void;
    /**
     * Resizes regions to specified dimensions
     * @param width - New `width` of the region
     * @param height - New `height` of the region
     */
    resize(width: number, height: number): void;
    /**
     * Changes the `point` at specified `index`
     * @param point - New `point` value
     * @param index - `index` of the point in internal collection
     */
    setPoint(point: IPoint2D, index: number): void;
    /**
     * Removes points from region and, if necessary, inserts new points in their place.
     * if start is < 0 it is reset to 0.
     * if start is > region points length it is reset to region points length.
     * *Region will be resized and repositioned automatically*
     * @param start The zero-based location in the array from which to start removing points.
     * @param deleteCount The number of points to remove.
     * @param points Points to insert into the array in place of the deleted points.
     */
    splicePoints(start: number, deleteCount?: number, ...points: IPoint2D[]): void;
    /**
     * Add or replace bezier controls at the designated index.
     * *Region will be resized and repositioned automatically*
     * @param index Line segment index to add the control to.
     * @param control Bezier control to add.
     */
    setBezierControl(index: number, control: ICubicBezierControl): void;
    /**
     * Add or replace bezier controls at the designated indexes.
     * *Region will be resized and repositioned automatically*
     * @param controls Map of bezier controls to line segment indexes.
     */
    setBezierControls(controls: Record<number, ICubicBezierControl>): void;
    /**
     * Delete bezier controls.
     * *Region will be resized and repositioned automatically*
     * @param index - `number | number[]` Indexes of bezier controls to delete.
     */
    deleteBezierControls(index: number | number[]): void;
    /**
     * Updates the collection of internal points.
     * @param points - `IPoint2D[]` collection for the region to serve as the source for the
     * internal *copy* in the `points` collection.
     * *Region will be resized and repositioned automatically*
     *
     * @deprecated setPoints does not work with path regions which contain bezier control points
     * use set/splice methods instead
     */
    setPoints(points: IPoint2D[]): void;
    /**
     * Inits this region properties from another `IRegionData` object
     * @param regionData - An `IRegionData` object to serve as the source for the property values
     */
    initFrom(regionData: IRegionData): void;
    /**
     * Returns a new `RegionData` object with all coordinates and dimensions bounded to specified box
     * @param rect - The `IRect` box, which `width` and `height` will be used for bounding
     * @returns A new `RegionData` object
     */
    boundToRect(rect: IRect): RegionData;
    /**
     * Scale region coordinates, points and size by `xfactor` and `yfactor`
     * @param xfactor - Horizontal scaling factor
     * @param yfactor - Vertical scaling factor
     */
    scale(xfactor: number, yfactor: number): void;
    /**
     * Scale region coordinates, points and size by `factor`
     * @param factor - Horizontal & vertical scaling factor
     */
    scale(factor: number): void;
    /**
     * Creates a copy of this region data
     * @returns A new `RegionData` object with copied properties
     */
    copy(): RegionData;
    /**
     * Calculate line segments between each point in the region.
     * @returns ILineSegment[]
     */
    getLineSegments(): ILineSegment[];
    /**
     * Returns a string representation of the region in the format
     * `"{x, y} x [width, height]: {{x1, y1}, ..., {xn, yn}}"`.
     * @returns A string representation of the rect
     */
    toString(): string;
    /**
     * Transform regionData into an SVG path.
     */
    toPath(): string;
    /**
     * Transform regionData into set of line paths
     */
    toLinePathSegments(): string[];
    /**
     * Returns a JSON representation of the region
     * @returns An `IRegionData` object with properties only.
     */
    toJSON(): IRegionData;
    /**
     * _deleteBezierControls does not update the BBox, to allow code re-use with minimum necessary BBox recalculations.
     */
    private _deleteBezierControls;
    /**
     * _setBezierControls does not update the BBox, to allow code re-use with minimum necessary BBox recalculations.
     */
    private _setBezierControls;
    private resetBBox;
    private getLineSegmentCount;
}
