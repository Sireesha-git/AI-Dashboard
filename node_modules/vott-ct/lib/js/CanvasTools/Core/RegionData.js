"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegionData = exports.RegionDataType = void 0;
const calculateLineSegments_1 = require("../Core/Utils/calculateLineSegments");
const RegionDataType_1 = require("../Interface/RegionDataType");
Object.defineProperty(exports, "RegionDataType", { enumerable: true, get: function () { return RegionDataType_1.RegionDataType; } });
const CubicBezierControl_1 = require("./CubicBezierControl");
const CubicBezierIndex_1 = require("./CubicBezierIndex");
const Point2D_1 = require("./Point2D");
const Rect_1 = require("./Rect");
/**
 * Represents region meta-data, including position, size, points and type
 */
class RegionData {
    /**
     * Creates a new `RegionData` object
     * @param x - `x`-coordinate of the region
     * @param y - `y`-coordinate of the region
     * @param width - `width` of the region
     * @param height - `height` of the region
     * @param points - Collection of internal region points
     * @param type - `type` of the region from enum `RegionDataType`
     */
    constructor(x, y, width, height, points, type, bezierControls) {
        this.corner = new Point2D_1.Point2D(x, y);
        this.regionRect = new Rect_1.Rect(width, height);
        this.regionPoints = points !== null && points !== void 0 ? points : [];
        this.regionBezierControls = new CubicBezierIndex_1.CubicBezierIndex(bezierControls);
        this.regionType = type !== null && type !== void 0 ? type : RegionDataType_1.RegionDataType.Point;
    }
    /**
     * Creates a new `RegionData` object with `point`-type at provided `x`, `y` coordinates
     * @param x - `x`-coordinate
     * @param y - `y`-coordinate
     * @returns A new `RegionData` object
     */
    static BuildPointRegionData(x, y) {
        return new RegionData(x, y, 0, 0, [new Point2D_1.Point2D(x, y)], RegionDataType_1.RegionDataType.Point);
    }
    /**
     * Creates a new `RegionData` object with `rect`-type at provided `x`, `y`
     * coordinates and of provided `width` and `height`
     * @param x - `x`-coordinate
     * @param y - `y`-coordinate
     * @param width - `width` of the rect
     * @param height - `height` of the rect
     * @returns A new `RegionData` object
     */
    static BuildRectRegionData(x, y, width, height) {
        return new RegionData(x, y, width, height, [
            new Point2D_1.Point2D(x, y),
            new Point2D_1.Point2D(x + width, y),
            new Point2D_1.Point2D(x + width, y + height),
            new Point2D_1.Point2D(x, y + height),
        ], RegionDataType_1.RegionDataType.Rect);
    }
    /**
     * Creates a new `RegionData` object with `polygon`-type at provided `x`, `y`
     * coordinates and of provided `width` and `height`
     * @param x - `x`-coordinate
     * @param y - `y`-coordinate
     * @param width - `width` of the bounding rect
     * @param height - `height` of the bounding rect
     * @param points - the points that make up the polygon
     * @returns A new `RegionData` object
     */
    static BuildPolygonRegionData(x, y, width, height, points) {
        const region = new RegionData(x, y, width, height, points.map((p) => new Point2D_1.Point2D(p.x, p.y)), RegionDataType_1.RegionDataType.Polygon);
        return region;
    }
    /**
     * Creates a new `RegionData` object with `path`-type at provided `x`, `y`
     * coordinates and of provided `width` and `height`
     *
     * path region types can represent complex shapes including bezier curves
     *
     * @param x - `x`-coordinate
     * @param y - `y`-coordinate
     * @param width - `width` of the bounding rect
     * @param height - `height` of the bounding rect
     * @param points - the points the path
     * @param bezierControls - Map of bezier controls to lines in the path
     * @returns A new `RegionData` object
     */
    static BuildPathRegionData(x, y, width, height, points, bezierControls) {
        const region = new RegionData(x, y, width, height, points.map((p) => new Point2D_1.Point2D(p.x, p.y)), RegionDataType_1.RegionDataType.Path, CubicBezierIndex_1.CubicBezierIndex.buildFromJSON(bezierControls));
        return region;
    }
    /**
     * Creates a new `RegionData` object based on extracting specific properties from any provided object
     * @param data - An `IRegionData` object with `x`, `y`, `width`, `height`, `points` and `type` properties
     * @returns A new `RegionData` object
     */
    static BuildFromJson(data) {
        return new RegionData(data.x, data.y, data.width, data.height, data.points.map((p) => new Point2D_1.Point2D(p.x, p.y)), data.type, CubicBezierIndex_1.CubicBezierIndex.buildFromJSON(data.bezierControls));
    }
    /**
     * Gets the `x`-coordinate of the region
     */
    get x() {
        return this.corner.x;
    }
    /**
     * Sets the `x`-coordinate of the region. *Region points position will be recalculated*
     */
    set x(x) {
        this.move(x, this.y);
    }
    /**
     * Gets the `y`-coordinate of the region
     */
    get y() {
        return this.corner.y;
    }
    /**
     * Sets the `y`-coordinate of the region. *Region points position will be recalculated*
     */
    set y(y) {
        this.move(this.x, y);
    }
    /**
     * Gets the `width` of the region
     */
    get width() {
        return this.regionRect.width;
    }
    /**
     * Sets the `width` of the region. *Region points position will be recalculated*
     */
    set width(width) {
        this.resize(width, this.height);
    }
    /**
     * Gets the `height` of the region
     */
    get height() {
        return this.regionRect.height;
    }
    /**
     * Sets the `height` of the region. *Region points position will be recalculated*
     */
    set height(height) {
        this.resize(this.width, height);
    }
    /**
     * Returns the area of the region. *Point has area = 1.0, for other types it is `width * height`*
     */
    get area() {
        let area;
        if (this.regionType === RegionDataType_1.RegionDataType.Point) {
            area = 1.0;
        }
        else {
            area = this.regionRect.width * this.regionRect.height;
        }
        return area;
    }
    /**
     * Gets the bounding box size of the region
     */
    get boundRect() {
        return this.regionRect.copy();
    }
    /**
     * Sets the bounding box size of the region. *Region will be resized automatically*
     */
    set boundRect(rect) {
        this.resize(rect.width, rect.height);
    }
    /**
     * Gets the array of region points.
     */
    get points() {
        return this.regionPoints.map((p) => p.copy());
    }
    /**
     * Sets the array of region points. *Region will be resized and repositioned automatically*
     *
     * @deprecated directly setting point arrays does not work with path regions which contain bezier control points
     * use set/splice methods instead.
     */
    set points(points) {
        this.setPoints(points);
    }
    /**
     * Bezier controls mapped to line segment indexes.
     */
    get bezierControls() {
        return this.regionBezierControls.copy();
    }
    /**
     * Gets the type of the region
     */
    get type() {
        return this.regionType;
    }
    move(arg1, arg2) {
        const oldx = this.x;
        const oldy = this.y;
        this.corner.move(arg1, arg2);
        const dx = this.x - oldx;
        const dy = this.y - oldy;
        this.regionPoints.forEach((p) => {
            p.shift(dx, dy);
        });
        this.regionBezierControls = this.regionBezierControls.shift(dx, dy);
    }
    /**
     * Resizes regions to specified dimensions
     * @param width - New `width` of the region
     * @param height - New `height` of the region
     */
    resize(width, height) {
        const sx = width / this.width;
        const sy = height / this.height;
        this.regionRect.resize(width, height);
        const movePoint = (p) => {
            const px = (p.x - this.x) * sx + this.x;
            const py = (p.y - this.y) * sy + this.y;
            return new Point2D_1.Point2D(px, py);
        };
        this.regionPoints = this.regionPoints.map(movePoint);
        this.regionBezierControls = this.regionBezierControls.move(movePoint);
    }
    /**
     * Changes the `point` at specified `index`
     * @param point - New `point` value
     * @param index - `index` of the point in internal collection
     */
    setPoint(point, index) {
        if (index >= 0 && index < this.regionPoints.length) {
            this.regionPoints[index] = new Point2D_1.Point2D(point);
        }
        this.resetBBox();
    }
    /**
     * Removes points from region and, if necessary, inserts new points in their place.
     * if start is < 0 it is reset to 0.
     * if start is > region points length it is reset to region points length.
     * *Region will be resized and repositioned automatically*
     * @param start The zero-based location in the array from which to start removing points.
     * @param deleteCount The number of points to remove.
     * @param points Points to insert into the array in place of the deleted points.
     */
    splicePoints(start, deleteCount = 0, ...points) {
        const pointCount = this.regionPoints.length;
        const spliceStart = start < 0 ? start : start > pointCount ? pointCount : start;
        // delete bezier controls mapped to lines which connect to deleted points
        const bezDeleteIndexes = [];
        // lines are indexed by the point that they start from.
        // get line segment of point directly preceding starting point.
        if (spliceStart === 0) {
            // if it's the first point then wrap around to the ending point line segment.
            bezDeleteIndexes.push(pointCount - 1);
        }
        else {
            bezDeleteIndexes.push(spliceStart - 1);
        }
        for (let i = spliceStart; i < spliceStart + deleteCount; i++) {
            bezDeleteIndexes.push(i);
        }
        // adjust index of bezier controls based on # of deleted/added points
        const idxDiff = points.length - deleteCount;
        const newBezierRecord = {};
        this.regionBezierControls.forEach((control, idx) => {
            if (bezDeleteIndexes.includes(idx)) {
                return undefined;
            }
            if (idx >= spliceStart) {
                newBezierRecord[idx + idxDiff] = control.copy();
                return;
            }
            return (newBezierRecord[idx] = control.copy());
        });
        this.regionBezierControls = new CubicBezierIndex_1.CubicBezierIndex(newBezierRecord);
        this.regionPoints.splice(spliceStart, deleteCount, ...points.map((p) => new Point2D_1.Point2D(p)));
        this.resetBBox();
    }
    /**
     * Add or replace bezier controls at the designated index.
     * *Region will be resized and repositioned automatically*
     * @param index Line segment index to add the control to.
     * @param control Bezier control to add.
     */
    setBezierControl(index, control) {
        this.setBezierControls({ [index]: control });
    }
    /**
     * Add or replace bezier controls at the designated indexes.
     * *Region will be resized and repositioned automatically*
     * @param controls Map of bezier controls to line segment indexes.
     */
    setBezierControls(controls) {
        this._setBezierControls(controls);
        this.resetBBox();
    }
    /**
     * Delete bezier controls.
     * *Region will be resized and repositioned automatically*
     * @param index - `number | number[]` Indexes of bezier controls to delete.
     */
    deleteBezierControls(index) {
        this._deleteBezierControls(index);
        this.resetBBox();
    }
    /**
     * Updates the collection of internal points.
     * @param points - `IPoint2D[]` collection for the region to serve as the source for the
     * internal *copy* in the `points` collection.
     * *Region will be resized and repositioned automatically*
     *
     * @deprecated setPoints does not work with path regions which contain bezier control points
     * use set/splice methods instead
     */
    setPoints(points) {
        this.regionPoints = points.map((p) => new Point2D_1.Point2D(p));
        this.resetBBox();
    }
    /**
     * Inits this region properties from another `IRegionData` object
     * @param regionData - An `IRegionData` object to serve as the source for the property values
     */
    initFrom(regionData) {
        this.corner = new Point2D_1.Point2D(regionData.x, regionData.y);
        this.regionRect = new Rect_1.Rect(regionData.width, regionData.height);
        this.regionPoints = regionData.points.map((p) => new Point2D_1.Point2D(p.x, p.y));
        this.regionBezierControls = CubicBezierIndex_1.CubicBezierIndex.buildFromJSON(regionData.bezierControls);
    }
    /**
     * Returns a new `RegionData` object with all coordinates and dimensions bounded to specified box
     * @param rect - The `IRect` box, which `width` and `height` will be used for bounding
     * @returns A new `RegionData` object
     */
    boundToRect(rect) {
        const brCorner = new Point2D_1.Point2D(this.x + this.width, this.y + this.height).boundToRect(rect);
        const tlCorner = this.corner.boundToRect(rect);
        const width = brCorner.x - tlCorner.x;
        const height = brCorner.y - tlCorner.y;
        return new RegionData(tlCorner.x, tlCorner.y, width, height, this.regionPoints.map((p) => p.boundToRect(rect)), this.regionType, this.regionBezierControls.boundToRect(rect));
    }
    scale(f1, f2) {
        const xf = f1;
        const yf = f2 !== undefined ? f2 : f1;
        const scalePoint = (p) => {
            return new Point2D_1.Point2D(p.x * xf, p.y * yf);
        };
        const scaleRect = (r) => {
            return new Rect_1.Rect(r.width * xf, r.height * yf);
        };
        this.corner = scalePoint(this);
        this.regionRect = scaleRect(this);
        this.regionPoints = this.regionPoints.map(scalePoint);
        this.regionBezierControls = this.regionBezierControls.scale(scalePoint);
    }
    /**
     * Creates a copy of this region data
     * @returns A new `RegionData` object with copied properties
     */
    copy() {
        return new RegionData(this.x, this.y, this.width, this.height, this.regionPoints.map((p) => p.copy()), this.regionType, this.regionBezierControls.copy());
    }
    /**
     * Calculate line segments between each point in the region.
     * @returns ILineSegment[]
     */
    getLineSegments() {
        return calculateLineSegments_1.calculateLineSegments(this.regionPoints, { regionType: this.regionType });
    }
    /**
     * Returns a string representation of the region in the format
     * `"{x, y} x [width, height]: {{x1, y1}, ..., {xn, yn}}"`.
     * @returns A string representation of the rect
     */
    toString() {
        return `${this.corner.toString()} x ${this.boundRect.toString()}: {${this.regionPoints.toString()}}, {${this.regionBezierControls.toString()}}`;
    }
    /**
     * Transform regionData into an SVG path.
     */
    toPath() {
        const lineSegments = this.getLineSegments();
        const lineSegmentsLength = lineSegments.length;
        const points = this.regionPoints;
        const controlPoints = this.regionBezierControls;
        if (points.length === 1) {
            // move to first point and draw a circle of radius 1
            return `M${points[0].x},${points[0].y} m-1,0 a1,1 0 1 0 2,0 a1,1 0 1 0 -2,0`;
        }
        const pathSegments = [];
        for (let i = 0; i < lineSegmentsLength; i++) {
            const line = lineSegments[i];
            if (i === 0) {
                // move to first point
                pathSegments.push(`M${line.start.x},${line.start.y}`);
            }
            if (controlPoints[i]) {
                // curved line
                pathSegments.push(`C${controlPoints[i].c1.x},${controlPoints[i].c1.y} ${controlPoints[i].c2.x},${controlPoints[i].c2.y} ${line.end.x},${line.end.y}`);
            }
            else {
                // straight line
                pathSegments.push(`L${line.end.x},${line.end.y}`);
            }
        }
        return pathSegments.join(" ");
    }
    /**
     * Transform regionData into set of line paths
     */
    toLinePathSegments() {
        const lineSegments = this.getLineSegments();
        const lineSegmentsLength = lineSegments.length;
        const controlPoints = this.regionBezierControls;
        const pathSegments = [];
        for (let i = 0; i < lineSegmentsLength; i++) {
            const line = lineSegments[i];
            if (controlPoints[i]) {
                // curved line
                pathSegments.push(`M${line.start.x},${line.start.y} C${controlPoints[i].c1.x},${controlPoints[i].c1.y} ${controlPoints[i].c2.x},${controlPoints[i].c2.y} ${line.end.x},${line.end.y}`);
            }
            else {
                // straight line
                pathSegments.push(`M${line.start.x},${line.start.y} L${line.end.x},${line.end.y}`);
            }
        }
        return pathSegments;
    }
    /**
     * Returns a JSON representation of the region
     * @returns An `IRegionData` object with properties only.
     */
    toJSON() {
        return {
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height,
            points: this.regionPoints.map((point) => {
                return { x: point.x, y: point.y };
            }),
            bezierControls: this.regionBezierControls.toJSON(),
            type: this.regionType,
        };
    }
    /**
     * _deleteBezierControls does not update the BBox, to allow code re-use with minimum necessary BBox recalculations.
     */
    _deleteBezierControls(index) {
        const delIndexes = Array.isArray(index) ? index : [index];
        delIndexes.forEach((i) => delete this.regionBezierControls[i]);
    }
    /**
     * _setBezierControls does not update the BBox, to allow code re-use with minimum necessary BBox recalculations.
     */
    _setBezierControls(controls) {
        const lineCount = this.getLineSegmentCount();
        Object.entries(controls).forEach(([index, control]) => {
            const iIndex = Number(index);
            if (iIndex < 0 || iIndex >= lineCount) {
                return;
            }
            this.regionBezierControls[iIndex] = new CubicBezierControl_1.CubicBezierControl(control);
        });
    }
    resetBBox() {
        const { x: xmin, y: ymin, height, width } = Snap.path.getBBox(this.toPath());
        this.corner.move(xmin, ymin);
        this.regionRect.resize(width, height);
    }
    getLineSegmentCount() {
        const pointCount = this.regionPoints.length;
        if ([RegionDataType_1.RegionDataType.Polygon, RegionDataType_1.RegionDataType.Path].includes(this.regionType)) {
            // closing line segment from last to first point
            return pointCount;
        }
        return pointCount - 1;
    }
}
exports.RegionData = RegionData;
//# sourceMappingURL=RegionData.js.map