"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateLineSegments = void 0;
const RegionDataType_1 = require("../../Interface/RegionDataType");
function getPointsAlongLines(start, xLength, yLength) {
    return {
        oneThird: {
            x: start.x + xLength / 3,
            y: start.y + yLength / 3,
        },
        half: {
            x: start.x + xLength / 2,
            y: start.y + yLength / 2,
        },
        twoThird: {
            x: start.x + (2 * xLength) / 3,
            y: start.y + (2 * yLength) / 3,
        },
    };
}
function createLineSegment(start, end) {
    const xLength = end.x - start.x;
    const yLength = end.y - start.y;
    return {
        start,
        end,
        xLength,
        yLength,
        pointsAlongLine: getPointsAlongLines(start, xLength, yLength),
    };
}
function calculateLineSegments(points, options) {
    if (points.length < 2) {
        return [];
    }
    if (points.length === 2) {
        return [createLineSegment(points[0], points[1])];
    }
    const segments = [];
    const pointsLength = points.length;
    const loopLength = pointsLength - 1;
    for (let i = 0; i < loopLength; i++) {
        const nextPointIdx = i + 1;
        if (nextPointIdx < pointsLength) {
            segments.push(createLineSegment(points[i], points[nextPointIdx]));
        }
    }
    if ([RegionDataType_1.RegionDataType.Polygon, RegionDataType_1.RegionDataType.Path].includes(options === null || options === void 0 ? void 0 : options.regionType)) {
        // closing line segment from last to first point
        segments.push(createLineSegment(points[pointsLength - 1], points[0]));
    }
    return segments;
}
exports.calculateLineSegments = calculateLineSegments;
//# sourceMappingURL=calculateLineSegments.js.map