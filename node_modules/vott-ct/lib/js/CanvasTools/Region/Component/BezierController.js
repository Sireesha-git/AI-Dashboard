"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BezierController = void 0;
const Point2D_1 = require("../../Core/Point2D");
const IRegionCallbacks_1 = require("../../Interface/IRegionCallbacks");
const AnchorsComponent_1 = require("../Component/AnchorsComponent");
const DEFAULT_RADIUS = 6;
class BezierController {
    constructor(anchorComponent, paper, paperRect, regionData, anchorsNode, callbacks, createAnchor, subscribeToEvents) {
        this.anchorComponent = anchorComponent;
        this.paper = paper;
        this.paperRect = paperRect;
        this.regionData = regionData;
        this.anchorsNode = anchorsNode;
        this.callbacks = callbacks;
        this.createAnchor = createAnchor;
        this.subscribeToEvents = subscribeToEvents;
        this.isDragged = false;
        this.controlPoints = [];
    }
    buildAnchors() {
        this.buildControlPoints();
        this.controlGhostAnchor = this.createAnchor(this.paper, 0, 0, "ghost", AnchorsComponent_1.AnchorsComponent.DEFAULT_GHOST_ANCHOR_RADIUS);
        this.controlGhostAnchor.attr({
            display: "none",
        });
        this.anchorComponent.node.add(this.controlGhostAnchor);
        this.subscribeControlGhostToEvents(this.controlGhostAnchor);
    }
    redraw() {
        this.updateControlPoints();
    }
    updateControlPoints() {
        this.controlPoints.forEach((cp) => {
            cp.remove();
        });
        this.controlPoints = [];
        this.buildControlPoints();
    }
    subscribeControlPointToEvents(controlPoint, index, controlPointName) {
        this.subscribeToEvents([
            {
                event: "pointerenter",
                base: controlPoint.node,
                listener: () => {
                    // Set drag origin point to current anchor
                    this.activeControlPointId = { index, name: controlPointName };
                    const controlPoint = this.getActiveControlPoint();
                    if (controlPoint) {
                        // Move ghost anchor to current anchor position
                        window.requestAnimationFrame(() => {
                            this.controlGhostAnchor.attr({
                                cx: controlPoint.x,
                                cy: controlPoint.y,
                                display: "block",
                            });
                        });
                    }
                },
                bypass: false,
            },
        ]);
    }
    /**
     * Helper function to create a bezier control point.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param x - The `x`-coordinate of the anchor.
     * @param y - The `y`-coordinate of the anchor.
     * @param r - The radius of the anchor.
     */
    createControlPoint(paper, x, y, r = DEFAULT_RADIUS) {
        const point = paper.circle(x, y, r);
        point.addClass("bezierControlPointStyle");
        return point;
    }
    /**
     * Helper function to create a bezier control point tangent line.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param polylinePoints - Points to draw line on
     */
    createControlPointTangent(paper, polylinePoints) {
        const line = paper.polyline(polylinePoints);
        line.addClass("bezierControlPointTangentStyle");
        return line;
    }
    /**
     * Create Snap elements for control point and control point tangent line, in a group.
     * @param index - Index of line segment/control data
     * @param line - Line segment
     * @param control - Bezier control
     * @param pointName - `"c1" | "c2"` The point name id of the bezier control
     * @returns Group containing the control point element and its tangent line.
     */
    createControlPointGroup(index, line, control, pointName) {
        const g = this.paper.g();
        const pointBase = pointName === "c1" ? line.start : line.end;
        const controlPoint = control[pointName];
        const controlPointElem = this.createControlPoint(this.paper, controlPoint.x, controlPoint.y);
        const controlPointTangentElem = this.createControlPointTangent(this.paper, [
            pointBase.x,
            pointBase.y,
            controlPoint.x,
            controlPoint.y,
        ]);
        g.add(controlPointTangentElem);
        g.add(controlPointElem);
        this.subscribeControlPointToEvents(controlPointElem, index, pointName);
        return g;
    }
    /**
     * Creates SnapSVG UI of control points of each bezier control.
     */
    buildControlPoints() {
        const lineSegments = this.regionData.getLineSegments();
        this.regionData.bezierControls.forEach((control, index) => {
            const line = lineSegments[index];
            const c1Group = this.createControlPointGroup(index, line, control, "c1");
            this.anchorsNode.add(c1Group);
            const c2Group = this.createControlPointGroup(index, line, control, "c2");
            this.anchorsNode.add(c2Group);
            this.controlPoints.push(c1Group, c2Group);
        });
    }
    subscribeControlGhostToEvents(controlGhostAnchor) {
        const listeners = [
            {
                event: "pointerleave",
                base: controlGhostAnchor.node,
                listener: (e) => {
                    if (!this.isDragged) {
                        window.requestAnimationFrame(() => {
                            this.controlGhostAnchor.attr({
                                display: "none",
                            });
                        });
                    }
                },
                bypass: true,
            },
            {
                event: "pointermove",
                base: controlGhostAnchor.node,
                listener: (e) => {
                    if (this.isDragged) {
                        const ghost = e.target.getBoundingClientRect();
                        const rdx = e.clientX - ghost.left;
                        const rdy = e.clientY - ghost.top;
                        const offsetX = e.clientX - e.target.closest("svg").getBoundingClientRect().left;
                        const offsetY = e.clientY - e.target.closest("svg").getBoundingClientRect().top;
                        let dx = offsetX - this.dragOrigin.x;
                        let dy = offsetY - this.dragOrigin.y;
                        if ((rdx < 0 && dx > 0) || (rdx > 0 && dx < 0)) {
                            dx = 0;
                        }
                        if ((rdy < 0 && dy > 0) || (rdy > 0 && dy < 0)) {
                            dy = 0;
                        }
                        if (this.activeControlPointId) {
                            const controlPoint = this.getActiveControlPoint();
                            let p = new Point2D_1.Point2D(controlPoint.x + dx, controlPoint.y + dy);
                            if (this.paperRect !== null) {
                                p = p.boundToRect(this.paperRect);
                            }
                            window.requestAnimationFrame(() => {
                                this.controlGhostAnchor.attr({ cx: p.x, cy: p.y });
                            });
                            this.updateRegion(p);
                        }
                        this.dragOrigin = new Point2D_1.Point2D(offsetX, offsetY);
                    }
                },
                bypass: false,
            },
            {
                event: "pointerdown",
                base: controlGhostAnchor.node,
                listener: (e) => {
                    this.controlGhostAnchor.node.setPointerCapture(e.pointerId);
                    const offsetX = e.clientX - e.target.closest("svg").getBoundingClientRect().left;
                    const offsetY = e.clientY - e.target.closest("svg").getBoundingClientRect().top;
                    this.dragOrigin = new Point2D_1.Point2D(offsetX, offsetY);
                    this.isDragged = true;
                    this.callbacks.onManipulationLockRequest(this.anchorComponent);
                    this.callbacks.onChange(this.anchorComponent, this.regionData.copy(), IRegionCallbacks_1.ChangeEventType.MOVEBEGIN);
                },
                bypass: false,
            },
            {
                event: "pointerup",
                base: controlGhostAnchor.node,
                listener: (e) => {
                    this.controlGhostAnchor.node.releasePointerCapture(e.pointerId);
                    this.callbacks.onManipulationLockRelease(this.anchorComponent);
                    this.callbacks.onChange(this.anchorComponent, this.regionData.copy(), IRegionCallbacks_1.ChangeEventType.MOVEEND);
                    this.activeControlPointId = undefined;
                    this.dragOrigin = null;
                    this.isDragged = false;
                    window.requestAnimationFrame(() => {
                        this.controlGhostAnchor.attr({
                            display: "none",
                        });
                    });
                },
                bypass: false,
            },
        ];
        this.subscribeToEvents(listeners);
    }
    getActiveControlPoint() {
        if (this.activeControlPointId) {
            return this.regionData.bezierControls[this.activeControlPointId.index][this.activeControlPointId.name];
        }
        else {
            return null;
        }
    }
    updateRegion(p) {
        if (this.activeControlPointId) {
            const rd = this.regionData.copy();
            if (this.activeControlPointId) {
                const control = rd.bezierControls[this.activeControlPointId.index];
                if (control) {
                    control[this.activeControlPointId.name].move(p);
                    rd.setBezierControl(this.activeControlPointId.index, control);
                }
            }
            this.callbacks.onChange(this.anchorComponent, rd, IRegionCallbacks_1.ChangeEventType.MOVING);
        }
    }
}
exports.BezierController = BezierController;
//# sourceMappingURL=BezierController.js.map