"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DragComponent = void 0;
const Point2D_1 = require("../../Core/Point2D");
const IRegionCallbacks_1 = require("../../Interface/IRegionCallbacks");
const RegionComponent_1 = require("./RegionComponent");
/**
 * An abstract visual component used internall do allow dragging the whole region.
 */
class DragComponent extends RegionComponent_1.RegionComponent {
    /**
     * Creates a new `DragComponent` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     */
    constructor(paper, paperRect = null, regionData, callbacks) {
        super(paper, paperRect, regionData, callbacks);
        /**
         * Dragging state of the component.
         */
        this.isDragged = false;
        this.node = paper.g();
        this.node.addClass("dragLayer");
    }
    /**
     * Switches the component to the frozen state.
     */
    freeze() {
        super.freeze();
        this.isDragged = false;
        this.dragOrigin = null;
    }
    /**
     * Helper function to subscribe the draggable element to events.
     */
    subscribeToDragEvents() {
        const listeners = [
            {
                event: "pointerenter",
                base: this.dragNode.node,
                listener: (e) => {
                    if (this.isDragged) {
                        e.stopPropagation();
                    }
                },
                bypass: false,
            },
            {
                event: "pointermove",
                base: this.dragNode.node,
                listener: (e) => {
                    if (this.isDragged) {
                        const rect = e.target.getBoundingClientRect();
                        const rdx = e.clientX - rect.left;
                        const rdy = e.clientY - rect.top;
                        let dx = e.clientX - this.dragOrigin.x;
                        let dy = e.clientY - this.dragOrigin.y;
                        if ((rdx < 0 && dx > 0) || (rdx > this.width && dx < 0)) {
                            dx = 0;
                        }
                        if ((rdy < 0 && dy > 0) || (rdy > this.height && dy < 0)) {
                            dy = 0;
                        }
                        let p = new Point2D_1.Point2D(this.x + dx, this.y + dy);
                        if (this.paperRect !== null) {
                            p = p.boundToRect(this.paperRect);
                        }
                        this.dragOrigin = new Point2D_1.Point2D(e.clientX, e.clientY);
                        const rd = this.regionData.copy();
                        rd.move(p);
                        this.callbacks.onChange(this, rd, IRegionCallbacks_1.ChangeEventType.MOVING);
                    }
                },
                bypass: false,
            },
            {
                event: "pointerleave",
                base: this.dragNode.node,
                listener: (e) => {
                    // do nothing
                },
                bypass: false,
            },
            {
                event: "pointerdown",
                base: this.dragNode.node,
                listener: (e) => {
                    this.dragNode.node.setPointerCapture(e.pointerId);
                    const multiselection = e.ctrlKey;
                    this.isDragged = true;
                    this.dragOrigin = new Point2D_1.Point2D(e.clientX, e.clientY);
                    this.callbacks.onManipulationLockRequest(this);
                    this.callbacks.onChange(this, this.regionData.copy(), IRegionCallbacks_1.ChangeEventType.MOVEBEGIN, multiselection);
                },
                bypass: false,
            },
            {
                event: "pointerup",
                base: this.dragNode.node,
                listener: (e) => {
                    this.dragNode.node.releasePointerCapture(e.pointerId);
                    const multiselection = e.ctrlKey;
                    if (this.isDragged) {
                        this.callbacks.onChange(this, this.regionData.copy(), IRegionCallbacks_1.ChangeEventType.MOVEEND, multiselection);
                        this.isDragged = false;
                        this.dragOrigin = null;
                    }
                    this.callbacks.onManipulationLockRelease(this);
                    this.callbacks.onChange(this, this.regionData.copy(), IRegionCallbacks_1.ChangeEventType.SELECTIONTOGGLE, multiselection);
                },
                bypass: false,
            },
        ];
        this.subscribeToEvents(listeners);
    }
}
exports.DragComponent = DragComponent;
//# sourceMappingURL=DragComponent.js.map