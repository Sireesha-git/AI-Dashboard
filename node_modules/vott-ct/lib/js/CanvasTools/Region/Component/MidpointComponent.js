"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MidpointComponent = void 0;
const RegionComponent_1 = require("./RegionComponent");
/**
 * Component to represent mid-points along line segments in a region.
 */
class MidpointComponent extends RegionComponent_1.RegionComponent {
    /**
     * Creates a new `MidpointComponent` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     */
    constructor(paper, paperRect = null, regionData, callbacks) {
        super(paper, paperRect, regionData, callbacks);
        this.node = paper.g();
        this.node.addClass("midpointLayer");
        this.midpointElements = {};
        this.midpointNode = this.paper.g();
        this.node.add(this.midpointNode);
        const regionLineSegments = this.regionData.getLineSegments();
        this.buildMidpoints(regionLineSegments);
    }
    redraw() {
        const bezierControls = this.regionData.bezierControls;
        const regionLineSegments = this.regionData.getLineSegments();
        window.requestAnimationFrame(() => {
            this.updateMidpoints(bezierControls, regionLineSegments);
        });
    }
    /**
     * Helper function to create a new midpoint.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param x - The `x`-coordinate of the midpoint.
     * @param y - The `y`-coordinate of the midpoint.
     * @param style - Additional css style class to be applied.
     * @param r - The radius of the midpoint.
     */
    createMidpoint(paper, x, y, style, r = MidpointComponent.DEFAULT_RADIUS) {
        const midpoint = paper.circle(x, y, r);
        midpoint.addClass("midpointStyle");
        if (style !== undefined && style !== "") {
            midpoint.addClass(style);
        }
        return midpoint;
    }
    teardownMidpoints() {
        Object.values(this.midpointElements).forEach((midpointElement) => {
            midpointElement.remove();
        });
        this.midpointElements = {};
    }
    buildMidpoints(regionLineSegments) {
        this.teardownMidpoints();
        const bezierControls = this.regionData.bezierControls;
        regionLineSegments.forEach((line, index) => {
            if (bezierControls[index]) {
                // only create midpoints for straight lines
                return;
            }
            const midpoint = this.createMidpoint(this.paper, line.pointsAlongLine.half.x, line.pointsAlongLine.half.y);
            this.midpointElements[index] = midpoint;
            this.midpointNode.add(midpoint);
            this.subscribeMidpointToEvents(midpoint, index);
        });
    }
    updateMidpoints(bezierControls, regionLineSegments) {
        const toDelete = [];
        const toAdd = [];
        const toUpdate = [];
        // first check each line segment
        regionLineSegments.forEach((_line, idx) => {
            // this line segment has no bezier control data and doesn't have a midpoint element
            // need to add one
            if (!bezierControls[idx] && !this.midpointElements[idx]) {
                toAdd.push(idx);
                // this line segment has no bezier control data and does have a midpoint element
                // need to update it
            }
            else if (!bezierControls[idx] && this.midpointElements[idx]) {
                toUpdate.push(idx);
                // this line segment does have bezier control data and does have a midpoint element
                // need to remove it
            }
            else if (bezierControls[idx] && this.midpointElements[idx]) {
                toDelete.push(idx);
            }
        });
        // next check existing midpoint elements to see if
        // any are mapped to line segment that's been removed
        Object.entries(this.midpointElements).forEach(([idx]) => {
            if (!regionLineSegments[idx]) {
                toDelete.push(Number(idx));
            }
        });
        toDelete.forEach((idx) => {
            this.midpointElements[idx].remove();
            delete this.midpointElements[idx];
        });
        toAdd.forEach((idx) => {
            if (this.midpointElements[idx]) {
                this.midpointElements[idx].remove();
            }
            const midpoint = this.createMidpoint(this.paper, regionLineSegments[idx].pointsAlongLine.half.x, regionLineSegments[idx].pointsAlongLine.half.y);
            this.midpointElements[idx] = midpoint;
            this.midpointNode.add(midpoint);
            this.subscribeMidpointToEvents(midpoint, idx);
        });
        toUpdate.forEach((idx) => {
            const line = regionLineSegments[idx];
            this.midpointElements[idx].attr({
                cx: line.pointsAlongLine.half.x,
                cy: line.pointsAlongLine.half.y,
            });
        });
    }
}
exports.MidpointComponent = MidpointComponent;
/**
 * Default (visual) radius for midpoints.
 */
MidpointComponent.DEFAULT_RADIUS = 6;
//# sourceMappingURL=MidpointComponent.js.map