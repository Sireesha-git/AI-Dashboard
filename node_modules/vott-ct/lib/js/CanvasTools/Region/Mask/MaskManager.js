"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MasksManager = void 0;
const konva_1 = require("konva");
const constants_1 = require("../../Core/Utils/constants");
const ZoomManager_1 = require("../../Core/ZoomManager");
const ISelectorSettings_1 = require("../../Interface/ISelectorSettings");
class MasksManager {
    constructor(editorDiv, konvaDivHostElement, callbacks) {
        this.callbacks = callbacks;
        this.tagsList = [];
        this.maskSelectionMode = ISelectorSettings_1.SelectionMode.BRUSH;
        this.brushSize = {
            brush: 30,
            erase: 30,
        };
        this.editorDiv = editorDiv;
        this.konvaContainerHostElement = konvaDivHostElement;
        this.konvaContainerHostElement.style["z-index"] = constants_1.DisabledMaskHostZIndex;
        this.buildUIElements();
    }
    /**
     * sets the height and width of source image
     * @param width - width of image
     * @param height - height of image
     */
    setSourceDimensions(width, height) {
        this.sourceWidth = width;
        this.sourceHeight = height;
    }
    /**
     * enables and disables the masks manager with selected mask mode
     * @param enabled - indicates if mask selection is enabled
     * @param mode - optional. sets the mode of mask selection to either brush or eraser
     */
    setSelection(enabled, mode) {
        if (enabled) {
            this.maskSelectionMode = mode;
        }
        this.updateZIndex(enabled);
    }
    /**
     * sets the brush size
     * @param size - brush size
     */
    setBrushSize(size) {
        this.brushSize = size;
        this.setKonvaCursor();
    }
    /**
     * removes all masks and resets konva
     */
    eraseAllMasks() {
        this.resetKonvaLayer();
    }
    /**
     * Resizes the manager to specified `width` and `height`.
     * @param width - The new manager width.
     * @param height - The new manager height.
     * @param initialRender - Optional param if true, konvaStage scale is set at 1
     */
    resize(width, height, initialRender) {
        var _a;
        let zoomScale = 1;
        if (this.konvaStage) {
            if (initialRender) {
                const zoom = ZoomManager_1.ZoomManager.getInstance().getZoomData().currentZoomScale;
                this.konvaStage.scale({
                    x: 1 * zoom,
                    y: 1 * zoom,
                });
                this.konvaStage.width(width);
                this.konvaStage.height(height);
                this.rePositionStage();
                this.konvaStage.batchDraw();
                zoomScale = zoom;
            }
            else {
                const oldWidth = (_a = this.currentEditorDivWidth) !== null && _a !== void 0 ? _a : this.konvaStage.width();
                const existingScale = this.konvaStage.scaleX();
                const toBeScale = width / oldWidth;
                const expectedScale = existingScale * toBeScale;
                this.konvaStage.scale({
                    x: expectedScale,
                    y: expectedScale,
                });
                this.reSizeStage(width, height);
                this.rePositionStage();
                this.konvaStage.batchDraw();
                zoomScale = expectedScale;
            }
            this.currentEditorDivWidth = width;
            this.setKonvaCursor(zoomScale);
        }
    }
    /**
     * hides or shows masks of particular tag name
     * @param isVisible sets the visibility to true or false
     * @param tagName name of the tag to update visibility
     */
    updateMaskVisibility(isVisible, tagName) {
        this.updateMaskVisibilityInternal(isVisible, tagName);
    }
    /**
     * converts all polygons to mask
     */
    polygonsToMask() {
        this.convertRegionsToMask(this.canvasLayer);
    }
    /**
     * gets all the masks drawn on the canvas.
     */
    getAllMasks() {
        // show all and then get all masks
        const tagsVisibility = this.tagsList.map((tag) => {
            return {
                isVisible: true,
                name: tag.primary.name
            };
        });
        this.updateAllMaskVisibility(tagsVisibility);
        const currentDimensionsEditor = this.getCurrentDimension();
        const currentDimensions = {
            width: this.sourceWidth,
            height: this.sourceHeight,
        };
        const width = this.konvaStage.width();
        const height = this.konvaStage.height();
        const scaleX = this.konvaStage.scaleX();
        const scaleY = this.konvaStage.scaleY();
        const x = this.konvaStage.x();
        const y = this.konvaStage.y();
        // The konva stage is scaled back to zoom = 1 before extracting image data out of canvas
        // post that, the konvaStage is scaled back to its original dimensions
        this.konvaStage
            .width(currentDimensionsEditor.width)
            .height(currentDimensionsEditor.height)
            .scaleX(1)
            .scaleY(1)
            .x(0)
            .y(0);
        let canvas;
        canvas = this.canvasLayer.toCanvas({ pixelRatio: this.sourceWidth / currentDimensionsEditor.width });
        const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext("2d");
        const data = ctx.getImageData(0, 0, currentDimensions.width, currentDimensions.height);
        this.konvaStage.width(width).height(height).scaleX(scaleX).scaleY(scaleY).x(x).y(y);
        const imgData = data.data;
        const newData = new Array(currentDimensions.width * currentDimensions.height);
        newData.fill(0);
        const tagsListExist = [];
        this.tagsList.forEach((tags) => {
            const [r, g, b] = tags.primary.srgbColor.to255();
            const tagId = tags.primary.sequenceNumber;
            let tagExists = false;
            for (let i = 0; i <= data.data.length - 1; i = i + 4) {
                const ri = imgData[i];
                const gi = imgData[i + 1];
                const bi = imgData[i + 2];
                const t = 10;
                if ((ri >= r - t && ri <= r + t) && (gi >= g - t && gi <= g + t) && (bi >= b - t && bi <= b + t)) {
                    newData[i / 4] = tagId;
                    tagExists = true;
                }
            }
            tagsListExist.push(tagExists);
            ctx.clearRect(0, 0, currentDimensions.width, currentDimensions.height);
        });
        this.tagsList = this.tagsList.filter((tags, idx) => {
            return tagsListExist[idx];
        });
        return {
            imageData: newData,
            tags: this.tagsList,
        };
    }
    /**
     * Draws all the masks on the canvas
     * @param allMasks - all masks data to be drawn on canvas
     */
    loadAllMasks(allMasks) {
        this.initializeImageMask();
        this.loadMasksInternal(allMasks, this.canvasLayer);
    }
    /**
     * Removes antialiasing or smoothening from image data.
     * When drawing a shape on the canvas with smoothening on, the shape's edge has mixed pixel value
     * hence it looks curved. But when extracting image data out of canvas, we need each pixel to belong
     * to either of our tag colors. Hence if a pixel is on edge (its color value does not match any of the tag colors),
     * we look for the pixel value of its neighbouring 8 pixels to determine if we can assign the neighbours pixel value
     * to this pixel starting from topLeft pixel and going clockwise.
     */
    unSmoothenImageData(edgeArray, currentDimensions, imgData) {
        for (let i = 0; i <= edgeArray.length - 1; i++) {
            if (edgeArray[i] === 1) {
                const topLeft = i - currentDimensions.width - 1 < 0 ? 0 : i - currentDimensions.width - 1;
                const top = i - currentDimensions.width < 0 ? 0 : i - currentDimensions.width;
                const topRight = i - currentDimensions.width + 1 < 0 ? 0 : i - currentDimensions.width + 1;
                const current = i;
                const previous = i - 1 < 0 ? 0 : i - 1;
                const next = i + 1 > edgeArray.length - 1 ? edgeArray.length - 1 : i + 1;
                const bottomLeft = i + currentDimensions.width - 1 > edgeArray.length - 1
                    ? edgeArray.length - 1
                    : i + currentDimensions.width - 1;
                const bottom = i + currentDimensions.width > edgeArray.length - 1
                    ? edgeArray.length - 1
                    : i + currentDimensions.width;
                const bottomRight = i + currentDimensions.width + 1 > edgeArray.length - 1
                    ? edgeArray.length - 1
                    : i + currentDimensions.width + 1;
                const neighboringPixels = [];
                neighboringPixels.push(topLeft, top, topRight, previous, next, bottomLeft, bottom, bottomRight);
                const index = neighboringPixels.findIndex((j) => edgeArray[j] === 0);
                if (index >= 0) {
                    const pixel = neighboringPixels[index] * 4;
                    imgData[current * 4] = imgData[pixel];
                    imgData[current * 4 + 1] = imgData[pixel + 1];
                    imgData[current * 4 + 2] = imgData[pixel + 2];
                    imgData[current * 4 + 3] = imgData[pixel + 3];
                }
            }
        }
        return imgData;
    }
    /**
     * gets the pixels from the imageData that do not match any tag color. Hence they are edge pixels
     */
    getEdgePixelArray(imageData) {
        const edgeArray = [];
        for (let i = 0; i <= imageData.length - 1; i = i + 4) {
            let edgePixel = true;
            edgeArray[i / 4] = 0;
            const r = imageData[i];
            const g = imageData[i + 1];
            const b = imageData[i + 2];
            if (r !== 0 && g !== 0 && b !== 0) {
                this.tagsList.forEach((tags) => {
                    const [r1, g1, b1] = tags.primary.srgbColor.to255();
                    if (r === r1 && g === g1 && b === b1) {
                        edgePixel = false;
                    }
                });
                if (edgePixel) {
                    edgeArray[i / 4] = 1;
                }
            }
        }
        return edgeArray;
    }
    initializeImageMask() {
        if (!this.maskImage) {
            this.maskImage = new Image();
        }
    }
    updateMaskVisibilityInternal(isVisible, tagName) {
        const shapes = this.canvasLayer.getChildren(node => {
            return node.getAttr("name") === tagName;
        });
        shapes.forEach(shape => {
            shape.visible(isVisible);
        });
    }
    updateAllMaskVisibility(tags) {
        tags.forEach(tag => this.updateMaskVisibilityInternal(tag.isVisible, tag.name));
    }
    convertRegionsToMask(layer) {
        const allRegions = this.callbacks.getAllRegions();
        allRegions.forEach((polygon) => {
            const tags = polygon.tags;
            this.addTagsDescriptor(tags);
            const points = polygon.regionData.points;
            const bezierPoints = polygon.regionData.bezierControls;
            const polygonPoints = [];
            points.forEach((point, index) => {
                const nextIndex = index + 1 === points.length ? 0 : index + 1;
                const edge = {
                    start: {
                        x: point.x,
                        y: point.y,
                    },
                    end: {
                        x: points[nextIndex].x,
                        y: points[nextIndex].y,
                    },
                };
                if (bezierPoints[index] !== undefined) {
                    edge.controlPoint = bezierPoints.toJSON()[index];
                }
                polygonPoints.push(edge);
            });
            const bezierLineDestinationOut = new konva_1.default.Shape({
                globalCompositeOperation: "destination-out",
                stroke: "black",
                fill: "black",
                strokeWidth: 1,
                perfectDrawEnabled: false,
                closed: true,
                listening: false,
                opacity: 1,
                name: "eraserLine",
                sceneFunc: (ctx, shape) => {
                    ctx.beginPath();
                    ctx.moveTo(polygonPoints[0].start.x, polygonPoints[0].start.y);
                    polygonPoints.forEach((edge) => {
                        if (edge.controlPoint) {
                            ctx.bezierCurveTo(edge.controlPoint.c1.x, edge.controlPoint.c1.y, edge.controlPoint.c2.x, edge.controlPoint.c2.y, edge.end.x, edge.end.y);
                        }
                        else {
                            ctx.lineTo(edge.end.x, edge.end.y);
                        }
                    });
                    ctx.closePath();
                    ctx.fillStrokeShape(shape);
                },
            });
            const bezierLineSourceOver = new konva_1.default.Shape({
                globalCompositeOperation: "source-over",
                fill: tags.primary.color,
                stroke: tags.primary.color,
                fillEnabled: true,
                perfectDrawEnabled: false,
                strokeWidth: 1,
                closed: true,
                listening: false,
                opacity: 1,
                name: tags.primary.name,
                sceneFunc: (ctx, shape) => {
                    ctx.beginPath();
                    ctx.moveTo(polygonPoints[0].start.x, polygonPoints[0].start.y);
                    polygonPoints.forEach((edge) => {
                        if (edge.controlPoint) {
                            ctx.bezierCurveTo(edge.controlPoint.c1.x, edge.controlPoint.c1.y, edge.controlPoint.c2.x, edge.controlPoint.c2.y, edge.end.x, edge.end.y);
                        }
                        else {
                            ctx.lineTo(edge.end.x, edge.end.y);
                        }
                    });
                    ctx.closePath();
                    ctx.fillStrokeShape(shape);
                },
            });
            if (layer) {
                layer.add(bezierLineDestinationOut);
                layer.add(bezierLineSourceOver);
                layer.draw();
            }
        });
    }
    loadMasksInternal(allMask, layer) {
        const currentDimensionsEditor = this.getCurrentDimension();
        const currentDimensions = {
            width: this.sourceWidth,
            height: this.sourceHeight,
        };
        if (currentDimensionsEditor &&
            !isNaN(currentDimensionsEditor.width) &&
            !isNaN(currentDimensionsEditor.height)) {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = "high";
            canvas.width = currentDimensions.width;
            canvas.height = currentDimensions.height;
            const newdata = ctx.createImageData(currentDimensions.width, currentDimensions.height);
            const imageDataAll = newdata.data;
            const imgData = allMask.imageData;
            const tags = allMask.tags;
            tags.forEach((tag) => {
                const [r, g, b] = tag.primary.srgbColor.to255();
                this.addTagsDescriptor(tag);
                for (let i = 0; i <= imgData.length - 1; i++) {
                    if (imgData[i] === tag.primary.sequenceNumber) {
                        imageDataAll[i * 4] = r;
                        imageDataAll[i * 4 + 1] = g;
                        imageDataAll[i * 4 + 2] = b;
                        imageDataAll[i * 4 + 3] = 255;
                    }
                }
            });
            newdata.data.set(imageDataAll);
            ctx.putImageData(newdata, 0, 0);
            this.maskImage.src = canvas.toDataURL();
            this.maskImage.onload = (_e) => {
                const newKonvaImg = new konva_1.default.Image({
                    image: this.maskImage,
                    height: currentDimensionsEditor.height,
                    width: currentDimensionsEditor.width,
                    perfectDrawEnabled: true
                });
                layer.add(newKonvaImg);
            };
        }
    }
    setKonvaCursor(zoomScale) {
        let size = this.maskSelectionMode === ISelectorSettings_1.SelectionMode.BRUSH ? this.brushSize.brush : this.brushSize.erase;
        size = Math.floor(size * (zoomScale !== null && zoomScale !== void 0 ? zoomScale : 1));
        const base64 = this.base64EncodedMaskCursor(size);
        const cursor = ["url('", base64, "')", " ", Math.floor(size / 2) + 4, " ", Math.floor(size / 2) + 4, ",auto"];
        this.konvaStage.container().style.cursor = cursor.join("");
    }
    base64EncodedMaskCursor(size) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = size + 8;
        canvas.height = size + 8;
        ctx.beginPath();
        ctx.arc(size / 2 + 4, size / 2 + 4, size / 2, 0, 2 * Math.PI, false);
        ctx.lineWidth = 2;
        ctx.strokeStyle = "white";
        ctx.stroke();
        return canvas.toDataURL();
    }
    updateZIndex(enabled) {
        this.konvaContainerHostElement.style["z-index"] = enabled ? constants_1.EnabledMaskHostZIndex : constants_1.DisabledMaskHostZIndex;
    }
    getScaledPointerPosition() {
        const transform = this.konvaStage.getAbsoluteTransform().copy();
        transform.invert();
        const position = this.konvaStage.getPointerPosition();
        const scaledPosition = transform.point(position);
        return scaledPosition;
    }
    addListeners() {
        let tag;
        let isPaint = false;
        let currentLine;
        let previousLine;
        this.konvaStage.on("mousedown", (e) => {
            const scaledPosition = this.getScaledPointerPosition();
            isPaint = true;
            tag = this.getTagsDescriptor();
            // delete any exisitng line/shape
            previousLine = new konva_1.default.Line(Object.assign({ globalCompositeOperation: "destination-out", strokeWidth: this.maskSelectionMode === ISelectorSettings_1.SelectionMode.BRUSH ? this.brushSize.brush : this.brushSize.erase, points: [scaledPosition.x, scaledPosition.y], name: "eraserLine" }, this.getLineShapeAttributes()));
            this.canvasLayer.add(previousLine);
            // add the new line
            currentLine = new konva_1.default.Line(Object.assign({ stroke: tag.primary.color, strokeWidth: this.maskSelectionMode === ISelectorSettings_1.SelectionMode.BRUSH ? this.brushSize.brush : this.brushSize.erase, globalCompositeOperation: this.maskSelectionMode === ISelectorSettings_1.SelectionMode.BRUSH ? "source-over" : "destination-out", points: [scaledPosition.x, scaledPosition.y], name: tag.primary.name }, this.getLineShapeAttributes()));
            this.canvasLayer.add(currentLine);
        });
        this.konvaStage.on("mouseup", (_e) => {
            isPaint = false;
            if (currentLine && currentLine.points().length < 3) {
                currentLine.destroy();
            }
            if (typeof this.callbacks.onMaskDrawingEnd === "function") {
                this.callbacks.onMaskDrawingEnd();
            }
        });
        this.konvaStage.on("mousemove", (_e) => {
            if (!isPaint) {
                return;
            }
            const scaledPosition = this.getScaledPointerPosition();
            // delete
            const newPointsToRemove = previousLine.points().concat([scaledPosition.x, scaledPosition.y]);
            previousLine.points(newPointsToRemove);
            // add
            const newPoints = currentLine.points().concat([scaledPosition.x, scaledPosition.y]);
            currentLine.points(newPoints);
        });
    }
    getCurrentDimension() {
        const zoom = ZoomManager_1.ZoomManager.getInstance().getZoomData().currentZoomScale;
        const style = getComputedStyle(this.editorDiv);
        return {
            width: parseInt(style.width, undefined) / zoom,
            height: parseInt(style.height, undefined) / zoom,
        };
    }
    getLineShapeAttributes() {
        return {
            lineCap: "round",
            lineJoin: "round",
            listening: false,
            tension: 0,
            perfectDrawEnabled: false,
            opacity: 1,
        };
    }
    reSizeStage(width, height) {
        const scrollContainer = document.getElementsByClassName("CanvasToolsContainer")[0];
        if (scrollContainer) {
            const style = getComputedStyle(scrollContainer);
            const maxWidth = parseFloat(style.width);
            const maxHeight = parseFloat(style.height);
            if (width <= maxWidth || height <= maxHeight) {
                this.konvaStage.width(width);
                this.konvaStage.height(height);
            }
            if (width > maxWidth && height > maxHeight) {
                this.konvaStage.width(maxWidth);
                this.konvaStage.height(maxHeight);
            }
        }
    }
    rePositionStage() {
        const scrollContainer = document.getElementsByClassName("CanvasToolsContainer")[0];
        if (scrollContainer) {
            const dx = scrollContainer.scrollLeft;
            const dy = scrollContainer.scrollTop;
            this.konvaStage.container().style.transform = "translate(" + dx + "px, " + dy + "px)";
            this.konvaStage.x(-dx);
            this.konvaStage.y(-dy);
        }
    }
    getTagsDescriptor() {
        var _a;
        const tag = this.callbacks.onMaskDrawingBegin();
        const primaryTagName = (_a = tag === null || tag === void 0 ? void 0 : tag.primary) === null || _a === void 0 ? void 0 : _a.name;
        if (!this.tagsList.find((tagObject) => { var _a; return ((_a = tagObject === null || tagObject === void 0 ? void 0 : tagObject.primary) === null || _a === void 0 ? void 0 : _a.name) === primaryTagName; })) {
            this.tagsList.push(tag);
        }
        return tag;
    }
    addTagsDescriptor(tag) {
        var _a;
        const primaryTagName = (_a = tag === null || tag === void 0 ? void 0 : tag.primary) === null || _a === void 0 ? void 0 : _a.name;
        if (!this.tagsList.find((tagObject) => { var _a; return ((_a = tagObject === null || tagObject === void 0 ? void 0 : tagObject.primary) === null || _a === void 0 ? void 0 : _a.name) === primaryTagName; })) {
            this.tagsList.push(tag);
        }
    }
    resetKonvaLayer() {
        this.canvasLayer.destroyChildren();
        this.canvasLayer.destroy();
        this.canvasLayer = new konva_1.default.Layer({});
        this.konvaStage.add(this.canvasLayer);
        this.tagsList = [];
    }
    buildUIElements() {
        const currentDimensionsEditor = this.getCurrentDimension();
        const stage = new konva_1.default.Stage({
            container: constants_1.KonvaContainerId,
            width: currentDimensionsEditor.width,
            height: currentDimensionsEditor.height,
        });
        this.sourceHeight = currentDimensionsEditor.height;
        this.sourceWidth = currentDimensionsEditor.width;
        this.canvasLayer = new konva_1.default.Layer({});
        stage.add(this.canvasLayer);
        this.konvaStage = stage;
        this.setKonvaCursor();
        this.addListeners();
        const scrollContainer = document.getElementsByClassName("CanvasToolsContainer")[0];
        scrollContainer === null || scrollContainer === void 0 ? void 0 : scrollContainer.addEventListener("scroll", () => this.rePositionStage());
    }
}
exports.MasksManager = MasksManager;
//# sourceMappingURL=MaskManager.js.map