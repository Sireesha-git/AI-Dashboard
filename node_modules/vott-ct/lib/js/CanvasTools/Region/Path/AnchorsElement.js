"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnchorsElement = void 0;
const ConfigurationManager_1 = require("../../Core/ConfigurationManager");
const Point2D_1 = require("../../Core/Point2D");
const IRegionCallbacks_1 = require("../../Interface/IRegionCallbacks");
const AnchorsComponent_1 = require("../Component/AnchorsComponent");
const BezierController_1 = require("../Component/BezierController");
var GhostAnchorAction;
(function (GhostAnchorAction) {
    GhostAnchorAction["Add"] = "add";
    GhostAnchorAction["Delete"] = "delete";
    GhostAnchorAction["None"] = "";
})(GhostAnchorAction || (GhostAnchorAction = {}));
/**
 * `AnchorsComponent` for the `PolygonRegion` class.
 */
class AnchorsElement extends AnchorsComponent_1.AnchorsComponent {
    /**
     * Creates a new `AnchorsElement` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     */
    constructor(paper, paperRect = null, regionData, callbacks) {
        super(paper, paperRect, regionData, callbacks);
        /**
         * The state of the current anchor action
         */
        this.ghostAnchorActionState = GhostAnchorAction.None;
        this.anchorsLength = regionData.points.length;
        const bezierController = new BezierController_1.BezierController(this, paper, paperRect, regionData, this.anchorsNode, callbacks, this.createAnchor.bind(this), this.subscribeToEvents.bind(this));
        bezierController.buildAnchors();
        this.mixins.push(bezierController);
    }
    set ghostAnchorAction(newValue) {
        this.ghostAnchor.removeClass("add");
        this.ghostAnchor.removeClass("delete");
        this.ghostAnchor.addClass(newValue);
        this.ghostAnchorActionState = newValue;
    }
    get ghostAnchorAction() {
        return this.ghostAnchorActionState;
    }
    /**
     * Redraws the component.
     */
    redraw() {
        if (this.regionData.points !== null && this.regionData.points.length > 0) {
            const points = this.regionData.points;
            // rebuild anchors
            if (this.anchorsLength !== points.length) {
                window.requestAnimationFrame(() => {
                    this.anchors.forEach((anchor) => {
                        anchor.remove();
                    });
                    this.anchors = [];
                    this.buildPointAnchors();
                });
                this.anchorsLength = points.length;
            }
            else {
                if (this.anchors.length > 0) {
                    window.requestAnimationFrame(() => {
                        this.regionData.points.forEach((p, index) => {
                            this.anchors[index].attr({
                                cx: p.x,
                                cy: p.y,
                            });
                        });
                    });
                }
            }
            this.updateAnchorLines();
        }
        this.mixins.forEach((m) => m.redraw());
    }
    /**
     * Creates a collection on anchors.
     */
    buildAnchors() {
        this.buildAnchorLines();
        super.buildAnchors();
    }
    /**
     * Creates polyline between anchor points.
     */
    buildAnchorLines() {
        const g = this.paper.g();
        g.addClass("anchorLineStyle");
        this.anchorsPolyline = g;
        this.regionData.toLinePathSegments().forEach((segment, idx) => {
            const path = this.paper.path(segment);
            g.add(path);
            this.subscribeLineToEvents(path, idx);
        });
        this.anchorsNode.add(this.anchorsPolyline);
    }
    /**
     * Updates polyline between anchor points.
     */
    updateAnchorLines() {
        this.anchorsPolyline.remove();
        this.buildAnchorLines();
    }
    /**
     * Subscribe an anchor to events.
     * @param anchor - The anchor to wire up with events.
     */
    subscribeLineToEvents(anchor, index) {
        this.subscribeToEvents([
            {
                base: anchor.node,
                event: "pointermove",
                listener: (e) => {
                    if (this.isModifyRegionOnlyModeEnabled(e)) {
                        this.activeAnchorIndex = -1;
                        const anchorPoint = this.getActiveAnchorPoint(e);
                        this.ghostAnchorLineIdx = index;
                        this.dragOrigin = anchorPoint;
                        this.ghostAnchorAction = GhostAnchorAction.Add;
                        window.requestAnimationFrame(() => {
                            this.ghostAnchor.attr({
                                cx: anchorPoint.x,
                                cy: anchorPoint.y,
                                display: "block",
                            });
                        });
                    }
                    else {
                        this.ghostAnchorAction = GhostAnchorAction.None;
                    }
                },
                bypass: false,
            },
        ]);
    }
    /**
     * Updated the `regionData` based on the new ghost anchor location.
     * @param p - The new ghost anchor location.
     */
    updateRegion(p) {
        const rd = this.regionData.copy();
        if (this.activeAnchorIndex > 0 && this.activeAnchorIndex <= this.regionData.points.length) {
            rd.setPoint(p, this.activeAnchorIndex - 1);
        }
        this.callbacks.onChange(this, rd, IRegionCallbacks_1.ChangeEventType.MOVING);
    }
    /**
     * Callback for the pointerenter event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerEnter(e) {
        if (this.isModifyRegionOnlyModeEnabled(e)) {
            if (this.regionData.points.length <= AnchorsElement.MIN_NUMBERS_OF_POINTS_PER_POLYGON) {
                this.ghostAnchorAction = GhostAnchorAction.Delete;
            }
        }
        else {
            this.ghostAnchorAction = GhostAnchorAction.None;
        }
        super.onGhostPointerEnter(e);
    }
    /**
     * Callback for the pointermove event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerMove(e) {
        if (this.isModifyRegionOnlyModeEnabled(e) && this.activeAnchorIndex !== 0) {
            const p = this.getActiveAnchorPoint(e);
            let dist = Number.MAX_VALUE;
            let index = -1;
            this.regionData.points.forEach((point, i) => {
                const d = p.squareDistanceToPoint(point);
                if (d < dist) {
                    dist = d;
                    index = i;
                }
            });
            const swapToDelete = dist < AnchorsElement.ANCHOR_POINT_LINE_SWITCH_THRESHOLD;
            if (this.activeAnchorIndex <= 0 && !swapToDelete) {
                this.ghostAnchorAction = GhostAnchorAction.Add;
                this.activeAnchorIndex = -1;
            }
            else if (this.regionData.points.length > AnchorsElement.MIN_NUMBERS_OF_POINTS_PER_POLYGON &&
                swapToDelete) {
                this.activeAnchorIndex = index + 1;
                this.ghostAnchorAction = GhostAnchorAction.Delete;
            }
        }
        else {
            this.ghostAnchorAction = GhostAnchorAction.None;
        }
        super.onGhostPointerMove(e);
    }
    /**
     * Callback for the pointerup event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerUp(e) {
        const rd = this.regionData.copy();
        if (this.ghostAnchorAction === GhostAnchorAction.Delete) {
            if (this.activeAnchorIndex > 0 && this.activeAnchorIndex <= this.regionData.points.length) {
                rd.splicePoints(this.activeAnchorIndex - 1, 1);
            }
            this.ghostAnchorAction = GhostAnchorAction.None;
            this.callbacks.onChange(this, rd, IRegionCallbacks_1.ChangeEventType.MOVEEND);
        }
        else if (this.ghostAnchorAction === GhostAnchorAction.Add) {
            const offsetX = e.clientX - e.target.closest("svg").getBoundingClientRect().left;
            const offsetY = e.clientY - e.target.closest("svg").getBoundingClientRect().top;
            const point = new Point2D_1.Point2D(offsetX, offsetY);
            // Get index of path segment that ghost anchor was on.
            const index = this.ghostAnchorLineIdx;
            rd.splicePoints(index + 1, 0, point);
            this.ghostAnchorAction = GhostAnchorAction.Delete;
            this.callbacks.onChange(this, rd, IRegionCallbacks_1.ChangeEventType.MOVEEND);
        }
        super.onGhostPointerUp(e);
    }
    /**
     * Returns `Point2D` with coordinates of active anchor
     */
    getActiveAnchorPoint(e) {
        if (this.activeAnchorIndex > 0) {
            return this.regionData.points[this.activeAnchorIndex - 1];
        }
        else if (this.activeAnchorIndex < 0) {
            const offsetX = e.clientX - e.target.closest("svg").getBoundingClientRect().left;
            const offsetY = e.clientY - e.target.closest("svg").getBoundingClientRect().top;
            return new Point2D_1.Point2D(offsetX, offsetY);
        }
        else {
            return null;
        }
    }
    isModifyRegionOnlyModeEnabled(event) {
        return ConfigurationManager_1.ConfigurationManager.isModifyRegionOnlyMode || (event === null || event === void 0 ? void 0 : event.ctrlKey);
    }
}
exports.AnchorsElement = AnchorsElement;
/**
 * Default threshold distance to define whether ctrl-pointer click is on point or line.
 */
AnchorsElement.ANCHOR_POINT_LINE_SWITCH_THRESHOLD = 5;
/**
 * The simplest polygon is a triangle, which has three points
 */
AnchorsElement.MIN_NUMBERS_OF_POINTS_PER_POLYGON = 3;
//# sourceMappingURL=AnchorsElement.js.map