"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AreaSelector = void 0;
const Rect_1 = require("../Core/Rect");
const ISelectorSettings_1 = require("../Interface/ISelectorSettings");
const MaskSelector_1 = require("./Selectors/MaskSelector");
const PointSelector_1 = require("./Selectors/PointSelector");
const PolygonSelector_1 = require("./Selectors/PolygonSelector");
const PolylineSelector_1 = require("./Selectors/PolylineSelector");
const RectCopySelector_1 = require("./Selectors/RectCopySelector");
const RectSelector_1 = require("./Selectors/RectSelector");
/**
 * The region selection manager.
 * @remarks The naming of the class is historical per the idea to specify the
 * region area to be selected. Thus AreaSelector.
 * @todo Consider renaming.
 */
class AreaSelector {
    /**
     * Creates a new `AreaSelector` manager.
     * @param svgHost - The host SVG element.
     * @param callbacks - The collection of callbacks.
     */
    constructor(svgHost, callbacks) {
        /**
         * Internal flag to track selector visibility.
         */
        this.isVisible = true;
        this.parentNode = svgHost;
        if (callbacks !== undefined) {
            this.callbacks = callbacks;
        }
        else {
            this.callbacks = {
                onLocked: null,
                onSelectionBegin: null,
                onSelectionEnd: null,
                onNextSelectionPoint: null,
                onUnlocked: null,
                onMaskSelection: null
            };
        }
        this.buildUIElements();
    }
    /**
     * Resizes selectors to specified `width` and `height`.
     * @param width - The new `width` for selector.
     * @param height - The new `height` for selector.
     */
    resize(width, height) {
        const [oldWidth, oldHeight] = [this.boundRect.width, this.boundRect.height];
        if (width !== undefined && height !== undefined) {
            this.boundRect.resize(width, height);
        }
        else {
            this.boundRect.resize(this.parentNode.width.baseVal.value, this.parentNode.height.baseVal.value);
        }
        if (this.selector !== null) {
            this.selector.resize(width, height, oldWidth, oldHeight);
        }
    }
    /**
     * Enables the current selector.
     */
    enable() {
        if (this.selector !== null) {
            this.selector.enable();
            this.selector.resize(this.boundRect.width, this.boundRect.height);
        }
    }
    /**
     * Disables the current selector.
     */
    disable() {
        if (this.selector !== null) {
            this.selector.disable();
        }
    }
    /**
     * Makes current selector visible and enabled.
     */
    show() {
        this.enable();
        this.isVisible = true;
    }
    /**
     * Makes current selector hidden and disabled.
     */
    hide() {
        this.disable();
        this.isVisible = false;
    }
    /**
     * Undo the last point drawn, if there is something to undo
     */
    undo() {
        if (this.selectorSettings.mode === ISelectorSettings_1.SelectionMode.POLYGON) {
            this.polygonSelector.undo();
        }
    }
    /**
     * Redo the last point that was undone
     */
    redo() {
        if (this.selectorSettings.mode === ISelectorSettings_1.SelectionMode.POLYGON) {
            this.polygonSelector.redo();
        }
    }
    /**
     * Returns whether or not a redo action can be performed, currently only supported for `PolygonSelector`
     */
    canRedo() {
        if (this.selectorSettings.mode === ISelectorSettings_1.SelectionMode.POLYGON) {
            return this.polygonSelector.canRedo();
        }
        return false;
    }
    /**
     * Returns whether or not an undo action can be performed, currently only supported for `PolygonSelector`
     */
    canUndo() {
        if (this.selectorSettings.mode === ISelectorSettings_1.SelectionMode.POLYGON) {
            return this.polygonSelector.canUndo();
        }
        return false;
    }
    setSelectionMode(settings) {
        var _a, _b, _c;
        let selectionSettings;
        if (settings === null || settings === undefined) {
            selectionSettings = {
                mode: ISelectorSettings_1.SelectionMode.NONE,
            };
        }
        else if (settings.mode !== undefined) {
            selectionSettings = settings;
        }
        else {
            selectionSettings = { mode: settings };
        }
        if (this.selectorSettings === undefined || this.selectorSettings.mode !== selectionSettings.mode) {
            this.disable();
            this.selectorSettings = selectionSettings;
            if (this.selectorSettings.mode === ISelectorSettings_1.SelectionMode.NONE) {
                this.selector = null;
                return;
            }
            else if (this.selectorSettings.mode === ISelectorSettings_1.SelectionMode.COPYRECT) {
                this.selector = this.rectCopySelector;
                const template = this.selectorSettings.template;
                if (template !== undefined) {
                    this.rectCopySelector.setTemplate(template);
                }
                else {
                    this.rectCopySelector.setTemplate(AreaSelector.DefaultTemplateSize);
                }
            }
            else if (this.selectorSettings.mode === ISelectorSettings_1.SelectionMode.RECT) {
                this.selector = this.rectSelector;
            }
            else if (this.selectorSettings.mode === ISelectorSettings_1.SelectionMode.POINT) {
                this.selector = this.pointSelector;
            }
            else if (this.selectorSettings.mode === ISelectorSettings_1.SelectionMode.POLYLINE) {
                this.selector = this.polylineSelector;
            }
            else if (this.selectorSettings.mode === ISelectorSettings_1.SelectionMode.POLYGON) {
                this.selector = this.polygonSelector;
            }
            else if (this.selectorSettings.mode === ISelectorSettings_1.SelectionMode.BRUSH) {
                (_a = this.maskSelector) === null || _a === void 0 ? void 0 : _a.enableMode(ISelectorSettings_1.SelectionMode.BRUSH);
            }
            else if (this.selectorSettings.mode === ISelectorSettings_1.SelectionMode.ERASER) {
                (_b = this.maskSelector) === null || _b === void 0 ? void 0 : _b.enableMode(ISelectorSettings_1.SelectionMode.ERASER);
            }
            // restore enabled status
            this.enable();
            if (this.isVisible) {
                this.show();
            }
            else {
                this.hide();
            }
            // disable if its a non mask mode selection
            if (this.selectorSettings.mode !== ISelectorSettings_1.SelectionMode.BRUSH &&
                this.selectorSettings.mode !== ISelectorSettings_1.SelectionMode.ERASER) {
                (_c = this.maskSelector) === null || _c === void 0 ? void 0 : _c.disable();
            }
        }
    }
    /**
     * Returns current options (settings) for selector.
     */
    getSelectorSettings() {
        return this.selectorSettings;
    }
    /**
     * Resets any in progress shape
     */
    reset() {
        if (this.selector !== null) {
            this.selector.reset();
        }
    }
    /**
     * Would be called after zoom to update the template for rect copy selector
     */
    updateRectCopyTemplateSelector(template) {
        if (template !== undefined) {
            this.rectCopySelector.setTemplate(template);
        }
        else {
            this.rectCopySelector.setTemplate(AreaSelector.DefaultTemplateSize);
        }
    }
    /**
     * Get the template for rect copy selector
     */
    getRectCopyTemplate(regions) {
        if (regions !== undefined && regions.length > 0) {
            const r = regions[0];
            return new Rect_1.Rect(r.regionData.width, r.regionData.height);
        }
        else {
            return new Rect_1.Rect(40, 40);
        }
    }
    /**
     * Creates UI of the AreaSelector.
     */
    buildUIElements() {
        this.paper = Snap(this.parentNode);
        this.boundRect = new Rect_1.Rect(this.parentNode.width.baseVal.value, this.parentNode.height.baseVal.value);
        this.areaSelectorLayer = this.paper.g();
        this.areaSelectorLayer.addClass("areaSelector");
        this.rectSelector = new RectSelector_1.RectSelector(this.parentNode, this.paper, this.boundRect, this.callbacks);
        this.rectCopySelector = new RectCopySelector_1.RectCopySelector(this.parentNode, this.paper, this.boundRect, new Rect_1.Rect(0, 0), this.callbacks);
        this.pointSelector = new PointSelector_1.PointSelector(this.parentNode, this.paper, this.boundRect, this.callbacks);
        this.polylineSelector = new PolylineSelector_1.PolylineSelector(this.parentNode, this.paper, this.boundRect, this.callbacks);
        this.polygonSelector = new PolygonSelector_1.PolygonSelector(this.parentNode, this.paper, this.boundRect, this.callbacks);
        this.maskSelector = new MaskSelector_1.MaskSelector(this.callbacks);
        this.maskSelector.disable();
        this.selector = this.rectSelector;
        this.rectSelector.enable();
        this.rectCopySelector.disable();
        this.pointSelector.disable();
        this.polylineSelector.disable();
        this.polygonSelector.disable();
        this.selector.hide();
        this.areaSelectorLayer.add(this.rectSelector.node);
        this.areaSelectorLayer.add(this.rectCopySelector.node);
        this.areaSelectorLayer.add(this.pointSelector.node);
        this.areaSelectorLayer.add(this.polylineSelector.node);
        this.areaSelectorLayer.add(this.polygonSelector.node);
    }
}
exports.AreaSelector = AreaSelector;
/**
 * Default template size for the `RectCopySelector`.
 * @todo Move to the `RectCopySelector` class.
 */
AreaSelector.DefaultTemplateSize = new Rect_1.Rect(20, 20);
//# sourceMappingURL=AreaSelector.js.map