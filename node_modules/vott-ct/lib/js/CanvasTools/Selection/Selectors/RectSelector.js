"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RectSelector = exports.SelectionModificator = void 0;
const Point2D_1 = require("../../Core/Point2D");
const Rect_1 = require("../../Core/Rect");
const RegionData_1 = require("../../Core/RegionData");
const AlternatingCrossElement_1 = require("../Component/AlternatingCrossElement");
const RectElement_1 = require("../Component/RectElement");
const Selector_1 = require("./Selector");
/**
 * Enum to specify selection mode.
 */
var SelectionModificator;
(function (SelectionModificator) {
    SelectionModificator[SelectionModificator["RECT"] = 0] = "RECT";
    SelectionModificator[SelectionModificator["SQUARE"] = 1] = "SQUARE";
})(SelectionModificator = exports.SelectionModificator || (exports.SelectionModificator = {}));
/**
 * The selector to define a rect-region.
 */
class RectSelector extends Selector_1.Selector {
    /**
     * Creates new `RectSelector` object.
     * @param parent - The parent SVG-element.
     * @param paper - The `Snap.Paper` element to draw on.
     * @param boundRect - The bounding box.
     * @param callbacks - The collection of callbacks.
     */
    constructor(parent, paper, boundRect, callbacks) {
        super(parent, paper, boundRect, callbacks);
        /**
         * Internal flag for selection state.
         */
        this.capturingState = false;
        /**
         * Pointer Id for capturing
         */
        this.pointerCaptureId = -1;
        /**
         * Internal flag for selection mode.
         */
        this.isTwoPoints = false;
        /**
         * Internal flag for selection type.
         */
        this.selectionModificator = SelectionModificator.RECT;
        /**
         * Internal flag to control keyboard cursor mode.
         */
        this.usingKeyboardCursor = false;
        this.buildUIElements();
        this.hide();
    }
    /**
     * Resizes the selector to specified `width` and `height`.
     * @param width - The new `width`.
     * @param height - The new `height`.
     */
    resize(width, height) {
        super.resize(width, height);
        this.resizeAll([this.selectionBox, this.crossA, this.crossB]);
    }
    /**
     * Resets any in progress shape
     */
    reset() {
        this.buildUIElements();
    }
    /**
     * Hides the selector.
     */
    hide() {
        super.hide();
        this.hideAll([this.crossA, this.crossB, this.selectionBox]);
        if (this.pointerCaptureId >= 0) {
            this.parentNode.releasePointerCapture(this.pointerCaptureId);
            this.pointerCaptureId = -1;
        }
    }
    /**
     * Shows the selector.
     */
    show() {
        super.show();
        this.crossA.show();
    }
    /**
     *  Returns the member variable `usingKeyboardCursor`
     */
    getUsingKeyboardCursor() {
        return this.usingKeyboardCursor;
    }
    /**
     * Helper function to start the use of keyboard cursor controls.
     */
    activateKeyboardCursor() {
        this.usingKeyboardCursor = true;
        this.curKeyboardCross = this.crossA;
        this.isTwoPoints = true;
        this.capturingState = false;
        this.showAll([this.crossA]);
        this.hideAll([this.crossB, this.selectionBox]);
    }
    /**
     * Helper function to stop the use of keyboard cursor controls.
     */
    deactivateKeyboardCursor() {
        this.usingKeyboardCursor = false;
        this.curKeyboardCross = null;
    }
    /**
     * Builds selector's UI.
     */
    buildUIElements() {
        this.node = this.paper.g();
        this.node.addClass("rectSelector");
        this.crossA = new AlternatingCrossElement_1.AlternatingCrossElement(this.paper, this.boundRect);
        this.crossB = new AlternatingCrossElement_1.AlternatingCrossElement(this.paper, this.boundRect);
        this.selectionBox = new RectElement_1.RectElement(this.paper, this.boundRect, new Rect_1.Rect(0, 0));
        this.selectionBox.node.addClass("selectionBoxStyle");
        this.node.add(this.crossA.node);
        this.node.add(this.crossB.node);
        this.node.add(this.selectionBox.node);
        const listeners = [
            { event: "pointerenter", listener: this.onPointerEnter, base: this.parentNode, bypass: false },
            { event: "pointerleave", listener: this.onPointerLeave, base: this.parentNode, bypass: false },
            { event: "pointerdown", listener: this.onPointerDown, base: this.parentNode, bypass: false },
            { event: "pointerup", listener: this.onPointerUp, base: this.parentNode, bypass: false },
            { event: "pointermove", listener: this.onPointerMove, base: this.parentNode, bypass: false },
            { event: "keydown", listener: this.onKeyDown, base: window, bypass: false },
            { event: "keyup", listener: this.onKeyUp, base: window, bypass: true },
        ];
        this.subscribeToEvents(listeners);
    }
    /**
     * Helper function to move the rect element to specified locations.
     * @param box - The box to move.
     * @param pa - The first corner point.
     * @param pb - The opposite corner point.
     */
    moveSelectionBox(box, pa, pb) {
        const x = (pa.x < pb.x) ? pa.x : pb.x;
        const y = (pa.y < pb.y) ? pa.y : pb.y;
        const w = Math.abs(pa.x - pb.x);
        const h = Math.abs(pa.y - pb.y);
        box.move(new Point2D_1.Point2D(x, y));
        box.resize(w, h);
    }
    /**
     * Listener for the pointer enter event.
     * @param e PointerEvent
     */
    onPointerEnter(e) {
        window.requestAnimationFrame(() => {
            this.crossA.show();
        });
    }
    /**
     * Listener for the pointer leave event.
     * @param e PointerEvent
     */
    onPointerLeave(e) {
        window.requestAnimationFrame(() => {
            var _a, _b;
            const rect = this.parentNode.getClientRects();
            const p = new Point2D_1.Point2D(e.clientX - ((_a = rect[0]) === null || _a === void 0 ? void 0 : _a.left), e.clientY - ((_b = rect[0]) === null || _b === void 0 ? void 0 : _b.top));
            if (!this.capturingState) {
                this.hideAll([this.crossA, this.crossB, this.selectionBox]);
            }
            else if (this.isTwoPoints && this.capturingState) {
                this.moveCross(this.crossB, p);
                this.moveSelectionBox(this.selectionBox, this.crossA, this.crossB);
            }
        });
    }
    /**
     * Listener for the pointer down event.
     * @param e PointerEvent
     */
    onPointerDown(e) {
        window.requestAnimationFrame(() => {
            this.deactivateKeyboardCursor();
            if (!this.isTwoPoints) {
                this.capturingState = true;
                this.pointerCaptureId = e.pointerId;
                this.parentNode.setPointerCapture(this.pointerCaptureId);
                this.moveCross(this.crossB, this.crossA);
                this.moveSelectionBox(this.selectionBox, this.crossA, this.crossB);
                this.showAll([this.crossA, this.crossB, this.selectionBox]);
                if (typeof this.callbacks.onSelectionBegin === "function") {
                    this.callbacks.onSelectionBegin();
                }
            }
        });
    }
    /**
     * Listener for the pointer up event.
     * @param e PointerEvent
     */
    onPointerUp(e) {
        window.requestAnimationFrame(() => {
            var _a, _b;
            const rect = this.parentNode.getClientRects();
            const p = new Point2D_1.Point2D(e.clientX - ((_a = rect[0]) === null || _a === void 0 ? void 0 : _a.left), e.clientY - ((_b = rect[0]) === null || _b === void 0 ? void 0 : _b.top));
            if (!this.isTwoPoints) {
                this.capturingState = false;
                if (this.pointerCaptureId >= 0) {
                    this.parentNode.releasePointerCapture(this.pointerCaptureId);
                    this.pointerCaptureId = -1;
                }
                this.hideAll([this.crossB, this.selectionBox]);
                if (typeof this.callbacks.onSelectionEnd === "function") {
                    const x = Math.min(this.crossA.x, this.crossB.x);
                    const y = Math.min(this.crossA.y, this.crossB.y);
                    const w = Math.abs(this.crossA.x - this.crossB.x);
                    const h = Math.abs(this.crossA.y - this.crossB.y);
                    this.callbacks.onSelectionEnd(RegionData_1.RegionData.BuildRectRegionData(x, y, w, h));
                }
            }
            else {
                if (this.capturingState) {
                    this.endTwoPointSelection(p);
                }
                else {
                    this.startTwoPointSelection(p);
                }
            }
        });
    }
    /**
     * Listener for the pointer move event.
     * @param e PointerEvent
     */
    onPointerMove(e) {
        window.requestAnimationFrame(() => {
            var _a, _b;
            this.deactivateKeyboardCursor();
            const rect = this.parentNode.getClientRects();
            const p = new Point2D_1.Point2D(e.clientX - ((_a = rect[0]) === null || _a === void 0 ? void 0 : _a.left), e.clientY - ((_b = rect[0]) === null || _b === void 0 ? void 0 : _b.top));
            if (!this.isTwoPoints) {
                if (this.capturingState) {
                    this.moveCross(this.crossB, p, this.selectionModificator === SelectionModificator.SQUARE, this.crossA);
                    this.moveSelectionBox(this.selectionBox, this.crossA, this.crossB);
                }
                else {
                    this.moveCross(this.crossA, p);
                }
            }
            else {
                if (this.capturingState) {
                    this.moveCross(this.crossB, p, this.selectionModificator === SelectionModificator.SQUARE, this.crossA);
                    this.moveSelectionBox(this.selectionBox, this.crossA, this.crossB);
                }
                else {
                    this.moveCross(this.crossA, p);
                    this.moveCross(this.crossB, p);
                }
            }
        });
        e.preventDefault();
    }
    /**
     * Listener for the key down event.
     * @param e KeyboardEvent
     */
    onKeyDown(e) {
        // Holding shift key enable square drawing mode
        if (e.shiftKey) {
            this.selectionModificator = SelectionModificator.SQUARE;
        }
        if (e.ctrlKey && !this.capturingState) {
            this.isTwoPoints = true;
        }
        if (e.key === "k" || e.key.toLocaleUpperCase() === "K") {
            if (!this.usingKeyboardCursor) {
                // start keyboard mode
                this.activateKeyboardCursor();
            }
            else if (this.usingKeyboardCursor && !this.capturingState) {
                // set crossA
                this.startTwoPointSelection(this.curKeyboardCross);
                this.curKeyboardCross = this.crossB;
            }
            else if (this.usingKeyboardCursor && this.capturingState) {
                // set crossB
                this.endTwoPointSelection(this.curKeyboardCross);
                this.curKeyboardCross = this.crossA;
            }
        }
        if (!e.ctrlKey && e.shiftKey && this.isKeyboardControlKey(e.key) && this.usingKeyboardCursor) {
            e.preventDefault();
            this.moveKeyboardCursor(e.key);
        }
    }
    /**
     * Listener for the key up event.
     * @param e KeyboardEvent
     */
    onKeyUp(e) {
        // Holding shift key enable square drawing mode
        if (!e.shiftKey) {
            this.selectionModificator = SelectionModificator.RECT;
        }
        // Holding Ctrl key to enable two point selection mode
        if (!e.ctrlKey && this.isTwoPoints) {
            this.isTwoPoints = false;
            this.capturingState = false;
            this.moveCross(this.crossA, this.crossB);
            this.hideAll([this.crossB, this.selectionBox]);
        }
    }
    /**
     * Helper function for common logic to start a two point selection.
     * @param curPoint IPoint2D
     */
    startTwoPointSelection(curPoint) {
        this.capturingState = true;
        this.moveCross(this.crossB, curPoint);
        this.moveSelectionBox(this.selectionBox, this.crossA, this.crossB);
        this.showAll([this.crossA, this.crossB, this.selectionBox]);
        if (typeof this.callbacks.onSelectionBegin === "function") {
            this.callbacks.onSelectionBegin();
        }
    }
    /**
     * Helper function for common logic to end a two point selection.
     * @param curPoint IPoint2D
     */
    endTwoPointSelection(curPoint) {
        this.capturingState = false;
        this.hideAll([this.crossB, this.selectionBox]);
        if (typeof this.callbacks.onSelectionEnd === "function") {
            const x = Math.min(this.crossA.x, this.crossB.x);
            const y = Math.min(this.crossA.y, this.crossB.y);
            const w = Math.abs(this.crossA.x - this.crossB.x);
            const h = Math.abs(this.crossA.y - this.crossB.y);
            this.callbacks.onSelectionEnd(RegionData_1.RegionData.BuildRectRegionData(x, y, w, h));
        }
        this.moveCross(this.crossA, curPoint);
        this.moveCross(this.crossB, curPoint);
    }
    /**
     * Helper function to check if a key is used for controlling the keyboard cursor.
     * @param key string
     */
    isKeyboardControlKey(key) {
        return key === "ArrowUp" || key === "ArrowDown" || key === "ArrowLeft" || key === "ArrowRight";
    }
    /**
     * Helper function for common logic to move the keyboard cursor
     * @param key string
     */
    moveKeyboardCursor(key) {
        const nextPos = { x: this.curKeyboardCross.x, y: this.curKeyboardCross.y };
        switch (key) {
            // up
            case "ArrowUp":
                nextPos.y -= 20;
                break;
            // down
            case "ArrowDown":
                nextPos.y += 20;
                break;
            // left
            case "ArrowLeft":
                nextPos.x -= 20;
                break;
            // right
            case "ArrowRight":
                nextPos.x += 20;
                break;
            default:
                break;
        }
        this.moveCross(this.curKeyboardCross, nextPos);
        this.moveSelectionBox(this.selectionBox, this.crossA, this.crossB);
    }
}
exports.RectSelector = RectSelector;
//# sourceMappingURL=RectSelector.js.map